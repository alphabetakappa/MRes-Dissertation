\documentclass{article}

\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{gensymb}
\usepackage{caption}
\usepackage{geometry}
\usepackage{cite}

\DeclareMathOperator{\sech}{sech}
\DeclareMathOperator{\Tr}{Tr}

\usepackage{listings}
\usepackage{color}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

%\usepackage{minted}
%\begin{minted}{haskell}
 
\lstset{style=mystyle}





\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
	{-2.5ex\@plus -1ex \@minus -.25ex}%
	{1.25ex \@plus .25ex}%
	{\normalfont\normalsize\bfseries}}
\makeatother
\setcounter{secnumdepth}{4} % how many sectioning levels to assign numbers to
\setcounter{tocdepth}{4}    % how many sectioning levels to show in ToC in preamble





\geometry
{
  %body={6.5in, 8.5in},
  left=1.0in,
  top=1.25in
}

\setlength{\parindent}{10ex}









%\begin{figure}[H]
%	\centering
%	\includegraphics[scale=0.2]{rhul_logo}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%questions for chris
%is there a paper for the creation of InterDyne that can be referenced, or is the webpage all there is? ref webpage

%why do we need simple models of the finical markets, used to build the tools and methods that can then be used to analyse complex models/real fincial markets

%when to use et al , should i say clack and students [refrences]

%feedback loops that always return the same value, no dependces therefore not part of a loop 

%use the line "the work this paper is built on", interdyne project, creators or interdyne 


%how do I refer to code? figure? yes figure, refer to chapter

%is static analyses difficult on ABM? 

%why does the language need to be as simple as possible? make it easier to formally define and learn?

%what referencing style should I use?

%say that difference equations are top-down vs ABM that are bottom up


%nested where statements, are these ok? (when making infitie lists I put the functions in where statements, however they could already have a where statement)

%should I make everything an infite list regardless if it has a time component?

%all agent_ have time as fist component 

%can  I use pattern matchng in my transformed program?



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Things i need to do

%make sure I say that the time steps are of fixed width

%Compare difference equations and ABM in intro using the "TO AGENT-BASED SIMULATION FROM SYSTEM DYNAMICS" paper

%rewrite the syntax/grammer section with more examples and code and detail

%write the syntax section using the code to define it

%rewrite the example of use section 

%choose what example I am going to use to transform

%make sure code is colour coded correctly

%reader needs to think its interesting tough and say well done 

%make code figures 

%make new figure code refered to correctly in text 

%rewrite background to go with the introduction 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Re-Write intro

%Re-Write Background, example emergence so it feels less like an aside. Give enough detail of Interdyne that it can be used later when creting the transfromation desgin 

%Add to the description and alays what the challanges are 

%Write RR langauge section 

%Write Convertor section 

%Write Validation

%Wrtie test 

%Write Conclusion and further work 


\begin{document} 
\title{Design of a Transformation between a Set of Recurrence Relations and a Agent-Based Model}
\author{Leo Carlos-Sandberg\\
Supervisor: Dr Christopher D. Clack} 
\maketitle 

\begin{abstract}
\noindent {\it 
This paper investigates a method of describing interacting systems from two opposing view points, recurrence relations and agent-based models. These two methods take fundamentally different approaches with recurrence relations being top-down, and agent-based models being bottom-up.\\
Connecting these two methods allows for a more complete investigation of emergent behaviour occurring within interacting systems. Agent-based models offer an attractive way of analysing emergent behaviour, with the ability to investigate individual interactions throughout a simulation. Agent-based models however tend to be less well understood and accepted by non-computer science experts, this is in contrast to recurrence relation which are normally well understood. Creating a correctness preserving link between recurrence relations and agent-based models allows for simulations to be understood in their recurrence relation representation and hence have their agent-based model representation accepted. This is important in fields such as finance as it opens up new tools for economists and regulators to use in understanding emergence in complex markets.\\
This research comprises of the creation of a recurrence relation language, allowing for simulations to be defined, and the design of a step-by-step process by which a set of recurrence relations defined in this language can be converted into an agent-based model known as InterDyne.        
}
\end{abstract}




\newpage
\newgeometry{top = 2cm}
\tableofcontents
{\textit{ }}
\restoregeometry
\newpage



%\begin{figure}[H]
%	\centering
%	\includegraphics[scale=0.5]{spin_on_lattice}
%	\caption{\it The two-dimensional Ising model lattice.}
%	\label{fig:spins_on_lattice_demo}
%\end{figure} 

%\begin{equation}
%E = -J\sum_{\langle i,j \rangle}^{N} s_{i}s_{j} - h \sum_{i = 1}^{N} s_{i}.
%\end{equation}

%\label{1d_code}

%~\cite{GouldBook} 
%~\ref{s_the_ising_model} 


\section{Introduction}
%aim how to get economists to appreciate and use ABM and work based on ABM 

Complex systems have been an area of deep interest for a long time in many  fields such as, physics, biology and chemistry. More recently they have become an area of increased interest in the fields of economics and finance, especially as the markets which many researchers are interested in have become increasingly automated and interconnected.\\
Complex systems are of such interest to researchers because of the types of behaviour they can produce, emergence in these systems is of particular interest do to the fact that it can be very difficult to detect and predict, and have a large, some times, damaging impact on the system.\\
Emergent behaviour can occur in a large number of ways, but more often the behaviour of interest is created over a time period. In general there are two ways of viewing systems in time, these are either continuous, where the system progress through time smoothly. Or discrete, where the system takes equal quantised steps through time, with each step advancing the system.\\
Focussing on discrete time there are two main methods which can be used to model system set up in this way, recurrence relations and agent-based models. These two methods take fundamentally different views of a system, recurrence relations take a top down view and can be seen as a set of mathematical equations which make calls for the values of each other. Agent-based models take a bottom up approach and model different elements of the system as individual agents which communicate via messages passed between each other.\\
Both these methods are a viable way of modelling complex systems and have both been used for a long time in a large number of fields [REFS???]. Recurrence relations have a number of advantages such as:
\begin{itemize}
  \item Being well understood in a large number of fields. 
  \item Giving a formal mathematical definition of the whole system.
  \item Showing an obvious link between equations within the system. 
  \item Giving a static representation of the system.  
\end{itemize}
Agent-based modelling benefits include:
\begin{itemize}
  \item Being able to encode unique agents, with varying levels of complexity.
  \item Not having a defined behaviour for the system as a whole, as it is a bottom up approach.
  \item Giving a dynamic representation of the systems evolution. 
  \item Plainly showing the passing of information between agents. 
\end{itemize}          
The ability of agent-based models to track the communication between agents and their bottom up approach makes them particularly adapt at analysing emergent behaviour.\\  
As mentioned there has been a growing interest into complex systems and emergence within them in finance, a large part of this interest is on regulating theres systems to stop the creation of destructive emergent behaviour, this has been especially true when looking at high-frequency trading, which has been accused of causing a number of negative effects within the markets. This trading takes place at high speeds comparable to the tickets on a computers internal clock, meaning models of this trading typically while take a discrete time approach.\\
In literature on finance and economics there is a notable preference for recurrence relations over agent-based models, shown in Section~\ref{litreviewofabmrr}. This preference appears to be caused by agent-based models not resonating with researchers with less pure science backgrounds, such economists and industry expertise, and hence being less widely accepted.\\
This presents a problem for agent-based models and for researchers who wish to use them, making it less likely that researchers will choose to take an agent-based model approach, hence losing a valuable tool in investigating emergence, and that those who do will find it harder to publish and convince others of the results of their work.\\
This paper seeks to present a method where by agent-based models will resonate better with experts such as economists, and hence that they will be used more frequently and the research based upon them will be better accepted.\\    
The approach this paper takes is to connect an agent-based model to a set of recurrence relations, allowing the already accepted approach of recurrence relations to be a method for explaining and formalising the agent-based model. This connection between the models is coined as the two-views approach.\\
For this to be achieved there has to be confidence that the two views do indeed represent the same system, hence a correction preserving transformation needs to be achieved between the models. To reduce the difficulties in proving correctness and to assist a reader in understanding the transformation, the transformation should operate in a step-by-step manner.\\
This step-by-step transformation will take a set of recurrence relations and convert them into an agent-based model. This direction has been chosen opposed to the reverse as the aim is to encourage sceptics to engage with agent-based models and not as a why of simply proving the correctness of individual research using agent-based models. This trajectory will allow an individual to follow a set of recurrence relations as they are slowly converted in a set of simple steps to an agent-based model, showing how these two models can be linked and relate.\\
 













\begin{itemize}
  \item Introduce emergent behaviour (more importantly emergence in discrete time systems) 
  \item Methods for modelling emergence, recurrence relations and ABM  
  \item what ABM and RR are (in short, expanded on later) 
  \item Brief benefits of ABM and RR to be expanded later in analyses (not about ABM not being understood)
  \item Emergence in finance 
  \item There are problems with ABM leading to it not being widely accepted in finance (shown in section blah) 
  \item Why is this a problem? Lots of work has been done in ABM already, and its a good tool since it gives a different perspective  
  \item How to solve this problem? Can we use RR to give a formalisation to ABM? Yes its called two-views (a connection between the models)
  \item How would this be done? Need to have confidence that a RR formulation of a problem is identical to that of a ABM formalisation of the problem. Do in a step by step translation between the two models 
  \item RR to ABM, why? To encourage economists to engage with he modelling technique with using a familiar model, we are trying to make ABM a understood and valid model not just a why of writing RR
  \item Important: in making ABM a usable modelling system and also: in hypotheses formalisation, communicate between fields with different expertise like science and economics,  lot of good publish work has been done that hasn't resonated with economists so can be used to normalise the approach,  (also always for a two-views way of viewing problems being good for both static and dynamic analys)
  \item Timely: increased interest in ABM to understand complex behaviour of financial markets (lots of ref) 
  , this can be used to support other work done using ABM, and in making it a more relatable technique  
  \item This has three main parts: designing a transformation, creating code to do this, proving correctness (using lambda calculus) 
  \item Project Scope: this project is to designing the transformation 
  \item Difficulties in doing this (explained in detail in sec..): \begin{itemize}
  \item two paradigms are completely different 
  \item Differences between function calls and messages
  \item name control, in a way that allows for a useful and tangible ABM
  \item Show problem as a whole despite splintering 
  \item small steps can be hard to design but large steps are harder to prove correctness of 
\end{itemize}
  \item InterDyne is chosen as the example of an ABM (because: interesting features to do with interaction dynamics, have access to the sources code, designed to model finance, local expertise), costume RR language 
  \item Organisation of the paper 
\end{itemize}







%twovies holds regardless of what abm 
%have confidence that a RR formulation of a problem is identical to a given abm of the problem, and how I would do this. step y step translaftion between the models 
%choose interdyne as it has interesting feature to do with interaction dynamics, have acess to the sources code, and its been designed to model finance, local expertise, approach choose is interdyne is just an example of abm 

%Important 

%!what is the problem that I am addressing!

%!why is it an important problem!
%-important because of two views, which is important in processes of hypothiso fomulisation 
%-more then one experemt in different fields, can be used to communicate between fields (useful to have two different vies), in fumulating the hyphissm, having the write model 
%-lot of good published work that has been done in abm of finaical markets that hasnt resonated with ecomisits, because the apporach is not usual. 
%-why do it this way around, encourage econimist to engage with this form of moduling with use of RR, 
%-put timlness here
 
 %is this a timely project, what is it that can be done now that couldnt done before 
%-new increased intrest in agent based models in a way to understan the complex behviour of finacial markets (lots of refrences) 
 
%!why is it difficult!
%-two paridimes are so completely different
%-difernce between function calls and message passing 
%-issue of naming and name control (reuccrnace relations call any function from any wehre else, in agent based model you dont nessarsily want to do that, therefore need a concept of which functions together corrispond to a single agent, (for the finall agent based model to e interelgble and useful there has to be some user user input into selsecitng which RR to group into agents)) be done autmitaically neeeds user input about two views 
%-in chapter read 
%-why is it that econimists cant understand abm immidetly, they feel the problem has been splinter, and there is no understanding of how the problem comes together (no fomrul description)
%-DEVS model does give you overarching symatic (why is it not approate to model interarction dynamics) 





%for literate review
%compare abm and non abm of finacial markets and say that ecomists publish different papers 
%check if any one has done this before or anything similar 
%translating from RR to anything else 
%tralsing from anything to an agent based model 
%any one written anything on porcess fo program transformation by small steps, (lots in the late 80s), le brain phd theise (2000), desgined a programing langauge, approach he took to turn it into a functional langauge using step by step transoting (clover) 
%object flaw, paper 
%the clover rewrite rules, paper (this is the one i want)
%introducing clover and object oriented  functional langue, paper 



%in intro talk about scope, some parts of this problem whose implemtation would require a large time commitemnt to coe writing but design is in scope 
%in intro and alaysis state how different the interdyne and recurrance relations are  
Financial markets exhibit many interesting and some times unexpected events, one type of these such events are flash crashes. A notable example of this event type, is the flash crash of 2010, in this crash the E-min S\&P 500 equity futures market dropped in price by more then 5\%, during which time market prices and rational valuations became disconnected, before rebound to close to its original price~\cite{SECreport_delays, rareeventflashcrash}. This whole process occurred very rapidly, lasting approximately thirty-six minutes and has been described as``one of the most turbulent periods in their history'' for the US financial markets~\cite{Impact_hft}.\\
A number of flash crashes have been show to originate from large sell orders, such as in the recent crash in the cryptocurrency ethereum~\cite{cryptocrash}. The initial analysis of the 2010 flash crash came to a similar conclusion, with the  joint report by the U.S. Commodity Futures Trading Commission (CFTC) and Securities \& Exchange Commission (SEC), claiming that the crash was caused by a large sell order by a mutual fund\footnote{This process is explained in more detail in Section~\ref{applicabilut_to_finance}.}~\cite{SECreport_delays}. This initial finding is not fully accepted, even by the CFTC, who have since charged a trader with spoofing leading to the crash~\cite{spoofingtrader}.\\
A number of other causes have been suggested, with a particularly interesting suggestion being emergent behaviour between high-frequency traders known as ``hot-potato'' trading. Though not suggested as the root cause ``hot-potato'' trading was mentioned by SEC and CFTC to have occurred during the time of the crash. The idea that emergent behaviour could lead to a crash is not novel, with emergence causing a number of phase transition within physical systems, and has been suggested to be able to move a market between a stable and unstable phase before~\cite{networkcastphorynature}.\\
The high-frequency traders being discussed here are algorithmic traders who act as market makers, both buying and selling, trading on the nanosecond scale. These traders can under certain conditions end up passing inventory in a cyclic pattern between each other, this is ``hot-potato'' trading \footnote{Both high-frequency traders and ``hot-potato'' trading are discussed in more detail in Section~\ref{applicabilut_to_finance}.}.\\
Regulators struggle to find effective methods to reduce the likelihood of crash due to emergent behaviour. There is a lack of research on what directives could combat emergence induced flash crashes, partly because of the lack of agreement on exactly how these crashes are caused and if emergence can create them. Though research in this field is minimal, it has been shown that flash crashes can occur due to ``hot-potato'' trading~\cite{otherabmflash, DynamicCoupling_Chris}\footnote{Study \cite{DynamicCoupling_Chris} will be discussed in greater detail in section~\ref{InterDyne_section}.}. These studies took a bottom up approach by modelling the system as an agent-based model, and created a flash crash from ``hot-potato'' trading which was initiated by information delays.\\
Though these studies have managed to create a flash crash they use agent-based model methods, which have a number of draw backs leading to them not being commonly accepted by regulators\footnote{These draw backs will be discussed in more detail in Section~\ref{Iinterdynenotenough}.}, this makes them difficult to use in policy advisement.\\
This paper seeks to create a solution to this issue by constructing an automated transformation between a set of recurrence relations and an equivalent agent-based model. This solution will take a step-by-step approach, using a series of small correctness preserving transformations which when combined will transform between these two modelling techniques. Recurrence relations are more widely accepted by regulators and hence a should increase the acceptance of the related agent-based model, allowing this technique to be used to advice policies\footnote{This rational will be discussed further in Section~\ref{despriptionandanalysproblem}.}.\\
This method of transformation has a number of challenges associated with it: 
\begin{itemize}
  \item Recurrence relations and agent-based models are opposing models, with the former being top down and the latter being bottom up. Creating a conversion between entirely different models requires the fundamental mind set to be transformed.    
  \item It is not clear if a conversion process can even be broken down into a number of small steps. A larger step maybe be needed to move between to two stages in the transformation. Though larger steps will on the whole be easier to create proving their equivalence is much more challenging then smaller steps. %give an example of something that has been transformed and needed a large step
\end{itemize}
%%what does main compare to in intterdyne what are the symantic problems with this 
%should i keep the original rules at each step or can i use tuples/patternmatch etc, counter at some stage the code has to look interdyne code 
%interlectual issue spreading lists across time 
%what is broadcast! is all data public or private in RR?  
%should i keep the original rules at each step or can i use tuples/patternmatch etc, counter at some stage the code has to look interdyne code 
This paper is organised as follows. First an agent-based model used for modelling the financial market is described, followed by a analyses of this model and how recurrence relations can be used to combat its down sides. Section 4 details a bespoke recurrence relation language for describing a system, and Section 5 describes the step-by-step processes in which this language is transformed. Section 6 concludes the paper, detailing further work to be undertaken.    















%talk about flash crash (use some refrences from chris's unpublished paper) 
%-what was this
%-what was sec explanation for this (talk about sec saying it was a large sell order not hfts), this is how a large number of flash crashes have been shown to have been caused
%-not fully accepted, some people think it was caused by hfts 

%talk about hfts
%-what are hfts
%-how do they work

%how hfts might have caused the flash crash
%-change of phase, emergent behaviour  ~\cite{networkcastphorynature}
%-hot potato and delays
%-shown to have occurred during the flash crash

%regurlators are trying to work out how to stop crashes and regulate hfts 
%-how to regulate the markets and hfts and different algorthimgs, increase waiting times ect

%though research in this field is minimal some has been done by ~\cite{otherabmflash, DynamicCoupling_Chris} (chris will be discussed in more detail section 2
%-this is a bottom up approach to the problem (missing from the sec report)
%-seeing if flash crash could be caused by hotpotato and info delays
%-yes it can be caused by this 

%Problem with regulartors using ABM (they dont understand them)

%this paper seeks to create a solution be transforming in a step by step correctness preserving manner transforming Reccurrance relations (also known as differnce equations etc) into an agent-based model
%-recurrance realtions are more mathematical and better understood


%theoretical challenges with this

%organisation of the paper














%"when the crisis came, the serious limitations of existing economic and financial models become apparent" J. C. Trichet president of ECB 2010
%this is probably refering to loans but can say that the same applies to trading

%regulation is shifting from micro to macro-prudential perspective 
%managing individual risk to managing systemic risk

%USE THIS LINK
%\cite{fallacyofcompostionBook}
%talks about policy due to emergence 
%page 10 
%googled "fallacy of division emergent behaviour"

%introduce finicail markets
%Market Micrustrue, very research field at the cutting edge
%the need for interdyne, ergence in finciall markets is really investigated
%why i am doing what i am doing (need to example complex scientific predictions to econimsits etc)
%what i am doing (making a trasfeermation between DE and Agent based modeling)
%say that i am follwoing on from the work chris has done


%prove that the simulations are right
%Ability to provide confidence in the semantics of the system to economists and financial services industry practitioners
%Example ? difference equations (recurrence relations) ? provide a time-view, provides a way for economists to validate the description of the system (yes, we agree ? we understand these equations) 

%This research was inspired by the "Flash Crash" of 2010, this crash can be seen as a change in phase between a stable and unstable market; it has been shown that emergent behaviour in physical systems can lead to phase transitions and postulated that this could also be true within the financial markets~\cite{networkcastphorynature}. InterDyne hence exists to see if this flash crash and ones like it could be examples of this critical behaviour caused by emergence within the markets


%Comparison between recurrance relations and agent based models has be discussed in a number of papers, Refs
%modeling complex systems to observe unpretected and possibly harmful emergent behivour
%



%Introduction
%?This chapter introduces the motivations for the research, briefly describes the design, implementation and test, presents the structure of the dissertation, and lists the contributions to science?
%1.1 Motivation
%1.2 Design
%1.3 Implementation
%1.4 Test
%1.5 Structure of the dissertation
%Chapter 2   Chapter 3   Chapter 4   Chapter 5  


%This chapter presents an overview of the thesis. First, the motivation for this research is introduced along with the research topic. Furthermore, the objectives of this research are discussed. Subsequently, this chapter describes the research and the scientific contributions of this thesis. This chapter ends by describing the structure of the whole thesis and showing a list of publications relating to this thesis that have been done so far.






%there is emenegce in the financial markets
%why do we want to understand emegrence in the fincnaial markets
%chalange with understnading emergence in the finical markets

%sobjective of this paper, allow econimists to understand emergence
%Interdyne already exists and can be uused to study emegrnce in fm
%problem is econimists dont understadn abm
%do understand recurrance relations
%create a method for transforming RR into abm
%unique to interdyne but the idea can be used to motiviate work in other abm that need explaining

%set up all the challenges 

%strutrue of this paper

%relevnt papers/research some wher ein here to

%\subsection{Challenges to This Work}
%going from recurrance relations to interdyne they are entirely different models.
%why are they different models 
%(shorter version of analyses of problem)

%not clear if it can be broken down into smaller steps and is possible, may need one big step. Have to prove big step is equvilent which is hard. smaller steps are much easier to prove equivalenet but harder to write. 
%is it possible to decompose into a sequence of small steps. Give example of something that cant be decompossed into small steps (then explain why my solution is not the same as this in the conclusion?) 

%theoretically why is this a hard problem 



\section{Background}
\begin{itemize}
  \item Say why this section is here (expands upon, emergence in finance, why we should instigate this, why has investigated this and how, interdyne, other peoples work on transformation) 
  \item Talk about what this section will cover and organisation 
\end{itemize}


%for literate review
%compare abm and non abm of finacial markets and say that ecomists publish different papers 
%check if any one has done this before or anything similar 
%translating from RR to anything else 
%tralsing from anything to an agent based model 
%any one written anything on porcess fo program transformation by small steps, (lots in the late 80s), le brain phd theise (2000), desgined a programing langauge, approach he took to turn it into a functional langauge using step by step transoting (clover) 
%object flaw, paper 
%the clover rewrite rules, paper (this is the one i want)
%introducing clover and object oriented  functional langue, paper 





%describe interdyne in a lt of detail so that the conversion later makes more sense, use diagrams
%rewrite a lot of this section to feel better 
This section will provide a background for this paper, detailing the emergent behaviour that is of interest and the methods used to investigate this behaviour.  





\subsection{Emergent Behaviour}
\begin{itemize}
  \item What is emergence (feed back loops, interaction dynamics)
  \item emergence in finance (crashes etc)
  \item why is this important (prevent/ predict crashes etc)
\end{itemize}

Emergent behaviour is a term used to describe macro-behaviour of a system that is not obvious from analysis of the micro-behaviour of the system, more formally this is behaviour that can not be predicted through analysis of any single component of a system \cite{EB_systemofsystemsGLangford}.\\
A misunderstanding of emergence can lead to the fallacy of division, this is that a property of the system as a whole most also be a property of an individual component of the system; water for example has a number of properties including being able to be cooled down to become ice and heated to become steam, saying the same must also be true of a molecule of water however is incorrect. This concept continues into economics, being called the fallacy of composition, where what is true for the whole economy my not hold for an individual and vice versa~\cite{fallacyofcompostionBook}.\\       
A simple way to demonstrate emergence is in the Game of Life~\cite{gameoflifepage}, which is an example of cellular automaton; this game takes place on an infinite two-dimensional grid in which cells can either be `alive', coloured for example green, or `dead', a different colour usually black. Wether a cell is `alive' or `dead' is based on a set of simple rules:   
\begin{enumerate}
  \item `Alive' cells will transition to be `dead' cells in the next time step if they have few than two `alive' neighbours.
  \item `Alive' cells with two or three `alive' neighbours remain `alive' at the next time step.
  \item `Alive' cells will transition to be 'dead' cells in the next time step if they have more than three `alive' neighbours.
  \item `Dead' cells with exactly three 'alive' neighbours will transition to `alive' at the next time step.
\end{enumerate}
With this simple set up very complex patterns evolving through time can be created, these patterns can be seen as emergence, with an individual cell not being able to encapsulate this behaviour. Natural phenomena similar to this is the formation of symmetries and patterns within snowflakes.\\
Emergent behaviour can be seen occurring naturally in many other cases, with physics offering a number of well explored examples. For instance the n-body problem~\cite{nbodyproblem}, this historically is explained as n planets interacting in such a way as to produce complex behaviour, despite each individual body following Newtonian laws. An interesting aspect of the n-body problem is that it can be reduced down to three bodies and still exhibit complex emergent behaviour. This example shows that a system need not be overly complex or large to display emergent behaviour, and that by showing the existence of emergence in a simplistic system one can infer its presence in more complex versions of that system.   


\subsubsection{Interaction Dynamics}
The emergent behaviour that is of interest to this paper is caused by interaction dynamics, this is the communication between different elements of a system. For instance in the above example of an n-body system, communication takes the form of gravitational interactions. Therefore the emergent behaviour of the system and the reason why each body does not have zero acceleration, is do to the gravitational interactions between the different bodies.  Gravity acts as a messenger in this system, telling each body about the mass and momentum of the others, and hence causing the other bodies to react, removing this messenger also removes the emergence and all the bodies would continue with constant velocities unless they physically collide~\cite{newtonconstantvelocity}.\\
Though this example deals with a very physical system, emergence may be created due to any form of communication between entities. An example of this is emergent behaviour in social systems where individuals can communicate and observe each other, but do not physically effect one another, this can lead to the forming or break down of social cooperation~\cite{socialemrgence}.


\subsubsection{Feedback Loops}
Emergent behaviour from interaction dynamics can take a number of forms, with a prominent type being feedback loops.\\
Feedback loops are where the input information to an entity is in some way dependent on the output information of that same entity, normally from a previous moment in time. In their simplest form this can just be a single entity supplying an input to its self, shown in Fig.~\ref{fig:exampleselffeedback}. For example if in Fig.~\ref{fig:exampleselffeedback}, $E1$ is a function that creates an output that is twice its input, given the initial input $1$ this would create the series of inputs: $1,2,4,8,....$.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{selffeedback}
	\caption{\it Simple feedback loop with an entity supplying its input from its output.}
	\label{fig:exampleselffeedback}
\end{figure} 
Feedback loops can be encompass multiple entities, in Fig.~\ref{fig:exampletwofeedback} a feedback loop is shown that encloses two different entities. A output from $E2$ is passed to $E3$ which in turn creates a new input for $E2$, though $E2$ input is not directly its own output, it does depend upon it. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{twofeedback}
	\caption{\it Feedback loop between two entities, with each output being transformed by the other entity before becoming an input.}
	\label{fig:exampletwofeedback}
\end{figure} 
A loop such as the one in Fig.~\ref{fig:exampletwofeedback}, is only considered a feedback loop if information is passed through out the entire loop. If $E3$ produced a constant output, or an output that does not depend upon its input from $E2$, then this would not be a feedback loop as the new input to $E2$ does not depend on its output.\\
These example are very simple, feedback loops can be much more complex, encompassing any number of entities, each of whom can have very complex algorithms for transforming their inputs. Feedback loops can operate across time, meaning that an event in the past can eventually feedback to a present decision. For a feedback loop containing a large number of entities the time scale on which the feedback occurs can be come significantly large.\\
Though feedback loops are often assumed to be a negative property, some can be stabilising due to a benign effect.\\
Feedback loops can be present in a system in two ways, either they can be a constant fixture, called a static feedback loop, or they can form and change, called a dynamic feedback loop. A static feedback loop is present in the system from the start whether this is intentional and known, or unintentional and unknown to the members of the system. Dynamic feedback loops may not be present at the start and can form and change over time, with new entities joining or leaving them, allowing them to increase or decrease in size or effect, to split or merge, or to disappear.\\
Due to the potential complexity of feedback loops both in construction and in time, they can be difficult to detect, therefore methods are usually used to expose them. For static loops, forms of static analysis can be used such as, analysing initial setup, this is possible since the loops do not change through out time. Dynamic loops can be much harder to observe and analyses, an important aspect to detecting these loops is the interactions, messages sent between different entities within the system. Since the loops can evolve over time being able to track and analyse these messages over a time series is vitally important for the analysis of these loops, this time dependent analyse is called dynamic analyse.  


\subsubsection{Emergence in Financial Markets}
Though emergence is prevalent in many disciplines, this paper is focussed on emergence in financial markets. The financial markets can be thought of as a large complex interacting system, which is the ideal environment for emergent behaviour. Events such as the formation of patterns, bubbles and crashes can all be seen as emergent behaviour caused by a variety of feedback loops~\cite{bubblesandcrashes}. This is similar to the complex interaction between short range and long range feedback loops in chemical reactions leading to pattern formation~\cite{turningchemical}.

\subsection{Methods for Modelling Emergent Behaviour in Finance}
\begin{itemize}
  \item In Discrete time!
  \item Discuss different methods for modelling financial emergent behaviour (papers)
  \item compare where non-ABM and ABM papers are published (re-affirm need for this work)
  \item  What is a ABM 
\end{itemize}

\subsubsection{Recurrences Relations} 

\begin{itemize}
  \item Say that there is an alternative modelling technique which doesn't share the same problems 
  \item Introduce Recurrence Relations, what they are etc 
  \item Show and describe them, to a level that any one should be able to understand what they are 
  \item talk about emergence in them
  \item Show why loops and emergence are not necessarily bad or hard wired obviously into the system
  \item Say their benefits and down sides  \begin{itemize}
  \item can't follow messages in a system
  \item can view history of states 
  \item are well accepted 
  \item can have a formal definition 
\end{itemize}
\end{itemize}

Recurrence relations connect a discrete set of elements in sequence, these elements are normally either numbers or functions, they can be used to define these sequences of produce the elements in them. They can be seen as equations that give the next term in a sequence based on the previous term or terms, hence defining said sequence. Recurrence relations are often used to define coefficients in series expansions, moments of weight functions, and members of families of special functions~\cite{recurrelationbook}.\\
The most simplistic form of a recurrence relation is one where the next term depends only on the immediately preceding term. If the $n^{th}$ element in the sequence is defined as  $x_{n}$, then this recurrence relation can be written as,    
\begin{equation}
x_{n+1} = f(x_{n}),
\end{equation}
where $f()$ is a function that calculates the next term based on the previous one. A recurrence relation does not just have to depend on its immediate previous term and can depend on any number of terms further back in the sequences, for example a recurrence relation depending on terms from two and three steps before can be written as, 
\begin{equation}
x_{n+1} = f(x_{n-1}, x_{n-2}),
\end{equation}
with $f()$ now taking two inputs to produce the new term in the sequence~\cite{recurrealtionwebpage}.\\
Recurrence relations can also be used to define a sequence through time, in the simplest case the enumerate $n$, can be set to represent time $t$, this is applicable to discrete time as it requires set steps between the different times. Just as in the previous examples, the simplest recurrence relation is,  
\begin{equation}
x_{t+1} = f(x_{t}),
\end{equation}
where $x_{t}$ is the term at time $t$ and $f()$ gives the term at $t+1$ based on the term at $t$. Again this can be expanded to include terms from a number of previous time steps, allowing the memory of the sequence to be shown.\\  
A recurrences relation for defining a sequences may as well as depending upon previous terms, also depend upon some parameter, $\alpha$, this would give, in its simplest case, 
\begin{equation}
x_{n+1} = f(x_{n}; \alpha).
\end{equation}
The next term in the sequence may not only depend on previous terms within its own sequence and paramters, it can also be conditional on another sequence. For example one sequence through out time, $x$, may depend on another sequence through out time, $y$, a simple recurrence relation for this could be,
\begin{equation}
x_{t+1} = f(x_{t}, y_{t}),
\end{equation}
with the sequence for $y$ possibly depending on its own recurrence relation. The sequence for $x$ may not even directly depend on its own sequence and could solely depend on $y$, 
\begin{equation}
x_{t+1} = f(y_{t}).
\end{equation}
Though it could also indirectly depend on its self, if $y$ was defined by a recurrence relation depending on $x$, such as, 
\begin{equation}
y_{t+1} = f(x_{t}).
\end{equation}
These cross sequence associations allow for complex interactions to be represented as time series defined by recurrence relations, this is a method which can be applied to agent-based modelling.\\
Reference~\cite{econmistsnoabm} showed how an agent-based model looking at the microstructure of the financial markets, can be exhibited in the form of recurrence relations. In their approach each agent with in an $n$ agent model is considered to be well described by a state variable, $x_{i, t}$. The state variable describes the agent at each time step, where $i$ is the identity of the agent $(i \in 1,2,....,n)$, and $t$ is the time step at which the agent is being described, i.e. $x_{1,5}$ describes the first agent at the fifth time step. These state variables are defined by the recurrence relation,     
\begin{equation} \label{eq:notimedelayrecur}
x_{i, t+1} = f_{i}(x_{i, t}, x_{-i,t}; \alpha_{i}),
\end{equation}
where $f_{i}()$ is a function unique to agent $i$, that can take the state of the agent at the previous time step, $x_{i, t}$, the state of any other agent at the previous time step, $x_{-i, t}$\footnote{The $-i$ is used to refer to all other agents in the system. So if $i=1$, $-i$ refers to agents $2,3,4,....,n$, for an $n$ agent system.}, and a bespoke parameter $\alpha_{i}$.\\
This method works by describing each agent as a sequence of state variables, these sequences are then interlinked by having dependencies to each other, allowing both the agents and their interactions to be represented. A simple example of this could be two agents, $x_{1}$ and $x_{2}$, that are coupled to each other and only depend on the others value at the previous time step and a parameter, represented by the recurrence relations,     
\begin{equation}
x_{1, t+1} = f_{1}(x_{2,t}; \alpha_{1}),
\end{equation}
\begin{equation}
x_{2, t+1} = f_{2}(x_{1,t}; \alpha_{2}).
\end{equation}
This formulation only shows relationships to the previous time steps, however information delays can be added to the system by allowing the recurrence relations to have a longer memory. A recurrence relation that uses a state variable from three time steps ago, could be considered to have a time delay of three time steps in receiving this information. The generalisation of the model needed to allow for this, is a recurrence relation of the form, 
\begin{equation}
x_{i, t+1} = f_{i}(x_{i, t}, x_{i, -t} x_{-i,t}, x_{-i, -t}; \alpha_{i}).
\end{equation}
This is similar to Eq.~\ref{eq:notimedelayrecur} but contains two new terms $x_{i, -t}$ and $x_{-i, -t}$, these terms are used to refer to any time steps before the previous one, time $t$. This more general equation can now reference any state variable from any previous time, from any agent, as well as its bespoke parameter, to compute the next term in its sequence.\\  
This models can be solved for macro-level properties by iteratively solving each state variable, $x_{i, t}$, given some initial conditions. This method of assessing the model gives it a formal definition, and one that is accessible by a larger range of experts then classic agent-based models. Recurrence relations in a number of forms are commonly used in economics and finance and hence are familiar and relatable to economists, this makes them a far more effective tool for describing models to these domain experts then agent-based models.\\
This iterative method for solving the equations makes any dependencies between systems apparent, as if $x_{2, t}$ is present in the definition of $x_{1, t+1}$, one can say that $x_{1,t+1}$ depends on $x_{2,t}$. This transparency of dependencies makes this formulation amenable to static analysis, allowing the recurrence relations to be investigated to return their static dependencies.\\
Although all recurrence relations will contain some form of recursive, since this is an intrinsic property, this will not necessarily be negative or destabilising. For example a dependency on a state at a previous time step may not be destabilising to the system, however the reverse would be a case where the state variable at $t+1$ depended on its self, this would be a destabilising loop. Static analysis hence could be used to detect hard-wired destabilising loops, such as the one just mentioned.\\
Static analyse of the system can become difficult when the functions $f_{i}()$ contain conditional statements relating to their inputs, this can cause inputs not to be used at certain times hence meaning dependencies will not be as obvious as simply the inputs given, this is a problem of determining wether a function will necessarily evaluate all its arguments~\cite{willevaluteargsa}.\\
Though through static analysis recurrence relations can be used to view the history of the state variables of a single agent, however the history of messages between pairs of agents is not easily detectable with static analysis. The interaction history is found through dynamic analysis which is not well suited to recurrence relations, as they lack a clear ability to follow the passing of messages within the system.   


\subsubsection{Agent-Based Models}
There are a number of different techniques to model emergent behaviour in complex systems, one popular method is agent-based modelling. Agent-based modelling can be considered more of a mind set then a rigid methodology, this involves describing the system in question in terms of its components and then allowing these to interact. Agent-based models allow a system to be described naturally and are hence the canonical approach to modelling emergent phenomena. This method is a bottom up approach, allowing for each component of the system, agent of the model, to be created to a relevant degree of abstraction~\cite{abmhumsystems}.\\
Agent-based models have been used to model a wide range of emergent behaviour including in the financial markets, examples of this are, noise traders~\cite{abmnoisetraders}, herding among traders~\cite{abmherding}, and fundamentalists~\cite{abmfundemetilists}.

\subsubsection{Review of Literature on Financial Model} \label{litreviewofabmrr}

\begin{itemize}
  \item Compare papers on RR and ABM and show that RR are used in finance papers more then ABM and hence the need for my project 
\end{itemize}

%RR
%https://link.springer.com/chapter/10.1007/978-3-642-46938-1_3 (book)
%https://books.google.co.uk/books?hl=en&lr=&id=o-clBQAAQBAJ&oi=fnd&pg=PA1&dq=recurrence+relations+finance+modelling&ots=v2yOVKquNP&sig=i0q6iZq3FHx_HEtvI4fsCQfmLD4#v=onepage&q=recurrence%20relations&f=false (book)
%https://books.google.co.uk/books?hl=en&lr=&id=7iGsCQAAQBAJ&oi=fnd&pg=PA185&dq=recurrence+relations+finance+modelling&ots=SPbejTEzwk&sig=qzu1gMUBiMCUtAFq1TSbP7YPKEc#v=onepage&q=recurrence&f=false (book)
%https://link.springer.com/chapter/10.1007%2F978-3-540-71297-8_41?LI=true (paper)
%http://www.jstor.org/stable/3481708?seq=1#page_scan_tab_contents (paper)
%https://www.researchgate.net/profile/Thomas_Mikosch/publication/2703398_Sample_ACF_of_Multivariate_Stochastic_Recurrence_Equations_With_Application_to_GARCH/links/54255bc90cf26120b7ac91db.pdf (paper draft)
%http://www.annualreviews.org/doi/abs/10.1146/annurev.economics.050708.142940 (paper)
%http://www.sciencedirect.com/science/article/pii/S0362546X97002356 (paper)
%http://www.sciencedirect.com/science/article/pii/S157400210502023X (paper)
%https://search.proquest.com/openview/f6cf1c4d1288dc7c9c2f34b31ab058e4/1?pq-origsite=gscholar&cbl=18750&diss=y (phd)
%




\subsection{InterDyne} \label{InterDyne_section}
\begin{itemize}
  \item Introduce InterDyne as the ABM which will be used here 
  \item Give a brief description of InterDyne 
  \item Say that we are using it because it is designed to investigate finance etc
  \item
\end{itemize}




InterDyne is bespoke simulator created by Clack and his research team at UCL~\cite{Chris_webPage}, it is a general-purpose simulator for exploring emergent behaviour and interaction dynamics within complex systems.\\
InterDyne design is that of an agent-based model interacting via a harness. This creates a structure of individual autonomous agents who interact through messages sent to one another.\\ 
Similar to other agent-based models InterDyne operates in discrete-time rather then continuous time. These quantised time chunks which move the simulation forward can be left with out proper definition, simply having operations defined in a number of time steps, or they can be equated to a real time usually with the smallest time gap needed be a single time step and then all other timings being integer multiples of this. This discrete time is most important to message passing, meaning messages between agents are only sent on a integer time step.\\ 
Massages in InterDyne are just small packets of data, such as a series of numbers.  Agents can only communicate via these messages, meaning that any emergent behaviour observed, that is not directly due to one agent, must be caused by linking of agents mediated by these messages. An agent can send private messages that are only received by a single other agents, one-to-one messages, or can send broadcast messages received by a number of agents, one-to-many messages. To facilitate this a communication topology can be made for InterDyne, this is done in the form of a directed graph determining which agents can communicate with each other. Due to the directional nature of these messages this topology could allow an agent to send messages to another but not be able to receive messages from that same agent. Messages have a defined order to them, an agent will, unless otherwise instructed, always process messages in the order in which they arrive. To change the order in which messages arrive delays can be added to communication paths between agents, this can be a static delay which always applies to messages sent from one agent to another, meaning this will arrive a set number of time steps later. Or a more complex dynamic delay, which is achieved by using another agent to mediate the passing of these messages delaying by an amount decided on in some internal logic. All messages in InterDyne are passed through a harness, this does not alter the messages or delay them\footnote{Unless instructed to using the static delay.}, but does store the messages and their order which can be used in post analyse.\\         
Each of the agents within an InterDyne simulation can be completely unique and modelled to different levels of complexity, as is the case with most agent-based models, allowing system components to be created to the level needed for the required experiment. As a whole InterDyne simulations are deterministic, repeated experiments will return identical results. However non-determinism can be added via the agents, making some part of an agent stochastic will lead to repeated experiments on the whole returning different results. A pseudo-random element can also be added by instructing InterDyne to randomly sort the message order for any agent receiving multiple messages in one time step. This is only pseudo-random as, as long as the same seed is used each run of the simulation will order the rearranged messages in the same way.\\
InterDyne is created to be particularly amenable to dynamic analyses of its simulations, this is achieved in part by all messages being sent via the harness allowing them to be stored in order.     


\subsubsection{Applicability to Finance} \label{applicabilut_to_finance}
%make sure I dont repeat stuff from the introduction 
%describe how a large order can cause a flash crash
%describe how high frequcey can cause that 

\begin{itemize}
  \item Explain the flash crash and that InterDyne is made to model it
  \item Explain how InterDyne is suited to modelling the flash crash 
  \item this should be a shortish section as it is not completely relevant (probably lose subheadings) 
\end{itemize}

Though InterDyne is a general purpose simulator, its main use thus far has been the exploration of financial markets. In particular InterDyne has been used to explore ``Flash Crash'' of 2010, during which market prices and rational valuations became disconnected, with some stocks trading as low as a penny per share, this lead to frenzied trading and irrational prices which spread between markets causing a massive price crash~\cite{SECreport_delays}. This event lasted around 36 minutes and has been described as``one of the most turbulent periods in their history'' for the US financial markets~\cite{Impact_hft}.\\
The hypotheses for this crash which InterDyne exists to investigate, is that this crash is an emergent phenomenon caused by the interaction between High Frequency Traders (HFTs) within the market.\\
HFTs are a subset of algorithmic traders who normally participate in the market as arbitrageurs or market makers, they invest in ultra-high speed technology allowing them to detect, analyses and react to market condition in nanoseconds \cite{hftinformation1}. This means HFTs can trade huge quantities of assets in very short time frames, with some estimates stating that 10-40\% of all trades where initiated by them during 2016 \cite{hftmarketparticipation}.\\
The type of interaction between these traders suggested to have caused the crash is ``Hot Potato'' trading, this is when inventory imbalance is repeatedly passed between HFTs market makers. A market maker is a trader who is required to have both a bid and a ask on the order book at all times, this means in theory that they are constantly buying and selling, a high frequency market maker as expected should be buying and selling very very often. Market makers make a profit from the spread and not long positions, hence they want to keep inventories low to avoid the market moving against them. To achieve this market makers have strict inventory limits that if they pass will cause them to go into what is know as a ``panic state'', during this state the trader will sell of an amount of its inventory to return back into its normal trading region. This inventory now solid by the market maker can be bought by another market maker causing them to in turn go into ``panic'' and sell, this process is ``Hot Potato'' trading and can in theory continue indefinitely~\cite{Elias_Paper}.\\
``Hot Potato'' trading was observed in the market during the ``Flash Crash''~\cite{SECreport_delays}, this is thought to have been caused by a combination of an initial large sell order by a mutual fund and delays in communication between HFTs maker makers and the exchange on which they were operating on, causing them to buy more inventory then they wanted and go into a ``panic state'' and hence a ``Hot Potato'' feedback loop.\\       %rewrite this a bit, add more detail
This section explains in more detail this hypotheses and how InterDyne is set up to investigate it.  

\paragraph{Deterministic}
The deterministic nature of InterDyne allows for experiments to be run multiple times with the same result always returned, this allows for changes to the experiment setup to be investigated. For example changing the number of traders in the market and comparing this to a previous run allows for an investigation into how many traders are required for emergent behaviour to be observed.\\
This becomes particularly interesting when comparing the interactions between market makers to that of the n-body problem, like with this problem one could expect emergent behaviour might occur to some extent in a large group of market makers, however the question of wether the emergence persists in a comparable market to the three-body problem and how this compares to a larger market can be investigated.   


\paragraph{Message Delays}
Allowing the delaying of messages is intrinsically important to the investigation of the hypotheses since the existence of delays is proposed as one of the main aspects in the ``Hot Potato'' trading that occurred. Delays exist between all aspects of the market which can account for the processing time of the different elements and the transmission time of messages between them. Some of these delays will be static but it has been preposed that the delays related to the exchange actually increased during the crashing, further worsening the situation~\cite{SECreport_delays}.\\
Static delays in built in InterDyne can be used to investigate the crash to see if it can occur without the need for dynamically varying delays. Dynamic delays created with agents can then be used to further investigate the events that occurred during the crash, allowing a situation to be set up where as more messages are sent to and from the exchange its delays increase.  Asymmetric delays can be specified between two agents allowing further investigation into the environment in which a crash is mostly likely to occur and how delays could be altered to reduce this out come. 

\paragraph{Message Passing}
To observe the decided system level behaviour, a flash crash, two different methods can be use; the behaviour can be encoded into the program forcing it occur at a system level, or the system can be setup to allow the behaviour to emerge at the system level. For a true understanding of emegernt behaviour the latter approach is more relevant, this requires the different agents within the simulation to be able to communicate directly with one another. In modelling the financial market these communications are in the form of messages sent between different entities, for example a trader could send a message to an exchange detailing a limit order they wish to issue and an exchange could send back a message containing a confirmation of this order.\\
These messages allow interaction dynamics to occur within the simulation and hence for emergent behaviour derived from interaction dynamics to naturally present within the system. 




\paragraph{Storing Messages}
Due to the nature of emegernt behaviour being usually unexpected, it can be very difficult to to deduce what low level structures and operations gave rise to this system level phenomenon. This is especially true when modelling a financial system that has a large number of interacting agents all sending and receiving messages, some of which can be delayed changing their expected order of arrival. The delays in the system have been suggested to have influenced the emergence of behaviour within the system, hence in investigating these systems it is important to take into account not only message counter-parties but also message timings. InterDyne facilitates post simulation analyse into this by being able to produce a trace for all time steps of the full information of; messages sent by any agent, messages received by any agent and messages being delayed before being delayed to an agent.          

  
\paragraph{Discrete Time}
Though it is easy to assume that the financial markets operate in continuous time this is in fact not always the case. For electronic markets that trade through an exchange their time is set by the exchange, orders are not processed and messages are not sent back till the exchange decides to do so. These electronic exchanges them selfs operate in discrete time, this is unavoidable and is a product of the systems being run on computers, a computer runs based on an internal clock that ticks in discrete intervals based on a change in a square-wave oscillating voltage. This change in voltage is so fast that to a human it seems continuous, however HFTs operate themselves at such high speeds that the system clock time gaps are comparable and hence need to be considered. Therefore models simulating HFTs interactions to this detail must take account of this discrete time, hence InterDynes discrete time nature is a good match to model HFTs interactions.     
     

\paragraph{Message Ordering}
The order in which messages are processed can be very important, for an exchange, for example, it can change whose limit order has priority at a given price and whose market order executes the lowest prices. Changing these factors can make or break feedback loops within the system, meaning if message ordering is not properly dealt with the correct emegernt behaviour may not be observed. Hence InterDyne stores messages in the order they are received by an agent, taking into account delays to the messages. This however can not be done when multiple messages are received at the same time step, due to the nature of discrete time there is no way for the agents to know which message arrived first, therefore two options are presented by InterDyne; messages are ordered according to their agent identifier %say what this is in a foot note?
or messages are randomised and executed in the  emerging order. This randomisation is handled in the same manner every run of the simulation \footnote{This can be changed using a new seed if so desired} hence resulting in the same order and therefore not effecting the deterministic nature of the experiment.  


\paragraph{Agents}
%expand this section

A benefit of agent based models of other alternatives is the ability to encode agents as unique traders instead of having to model the general behaviour of a number of traders. This allows for unique behaviour of varying complexity to be given to different agents, facilitating experimentation with different trading strategies, allowing different questions to be investigated, such as, does a trading strategy need to be complex for emergence to be observed? 




\subsubsection{InterDyne Detail Operation}

\begin{itemize}
  \item Explain in detail InterDynes operation
  \item The detail level here should be enough that the conversion later makes sense 
  \item Diagram of InterDynes operation 
  \item Introduce the harness and agents, as well as their types 
\end{itemize}

InterDyne is an agent-based model simulator written in the Haskell language. An InterDyne simulations structure, shown in Fig.~\ref{fig:harness_setupfigure}, consistent of a number of independent agents, sending messages to a ``Simulation Harness'', this harness then (i) sends these messages to the relevant counter party or parties \footnote{In the case of broadcast messages}, (ii) saves these messages to a trace file.   
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{harness_setup}
	\caption{\it Structure of an InterDyne simulation containing three agents.}
	\label{fig:harness_setupfigure}
\end{figure} 
%%%%%%use diagram from user manual
By set up each agent is required to both consume and produce a message at every time step, this is done by sending each agent a potentially-infinite list of messages and requiring it to create a potentially-infinite list of messages. The inbound list contains every message the agent will receive through out the entire simulation, ordered by time, and the outbound list contains every message the agent will ever send, order by time. This is possible due to lazy evaluation of the language that InterDyne is written in, This means that only messages being used are evaluated. Since no agent should attempted to use a message from the future \footnote{If they do an error will be thrown.}, only messages that have been created so far are read.\\
Since the set up of these list requires an element for every time step and an agent my not need to send a message during a time step, empty messages can be sent, this will result in an agent either receiving or sending an empty list. It may be the case in a simulation that an agent could be generating empty messages by mistake, to differentiate between a message empty by mistake or by choice, a message can be created containing ''Hiaton`` demonstrating that it is empty by choice.\\   
A InterDyne simulation once created can be run by executing the ''sim`` function with relevant arguments, this function has a type,      
\lstinputlisting[language=Haskell]{simplerunInterdyne.hs}
corresponding to, number of time steps, list of ``runtime arguments'', and a two tuple with the agents function and broadcast channels to which it is subscribed.\\
Agents within a simulation are defined by ID numbers, with the first agent having ID=1, followed by the second agent with ID=2,  ID=0 is used to represent the ``simulator harness''. These ID numbers are used to specify which agents messages are coming from and going to. This however can be difficult to keep track of within large experiments for the experimenter, therefore InterDyne allows for agents to be referred to by a name. This example shows InterDyne being run with the use of names for identification:     
\lstinputlisting[language=Haskell]{fullunInterdyne.hs}
This simulation will run for 60 time steps, with three agents subscribed to a number of broadcast channels, for example the third agent is subscribed to channel 2 and 3. There is a single run time argument convert, that can convert an ID to a name and a name to an ID. This is a simplistic call of the function sim, but shows how an experiment run could be setup and executed.\\   
In the example one can notice that the agents called all were to referred to as wrappers, this is because agents in InterDyne are typically, though not necessarily, written in two sections; ``wrapper'' and ``logic'' functions. The ``wrapper'' function, called in the example, can be thought of as the true agent, it handles message receiving and sending, as well as updating the local state of the function, hence this function is the one that interacts with the other agents and the harness. The ``logic'' function rests inside the ``wrapper'' function and computes the messages to be sent, hence this contains the functionality of the agent. An example of a ``wrapper'' function containing a ``logic'' function is shown here:
\lstinputlisting[language=Haskell]{complexagentwrapper.hs}
This agent will output a list containing message m, which is the output of the ``logic'' function for that given time period based on the received messages. The wrapper is a recursive function with each recursion being a new time step. It takes as inputs, st the local stat variable, args the run time arguments, a list of all messages to it, and its ID.  The list of messages has a three tuple for each time, containing the current time, list of all messages sent to the agent directly, and a list of all messages sent to the agent from broadcast channels.\\ 
InterDyne supports a wide range of messages in an array of complexities, to allow for a variety of interactions to take place. Messages, which are either one-to-one or broadcast, must all contain a pair of integers which represent the sending agents ID and the receiving agent or broadcast channels ID, the rest of the message depends on the type of message being sent. For example one could send a one-to-one message containing a list of (key, value) pairs, 
\lstinputlisting[language=Haskell]{message_simple.hs}
or a message carrying a string, 
\lstinputlisting[language=Haskell]{message_data.hs}
Broadcast messages content is defined by a broad type, which defined further within its type definition, 
\lstinputlisting[language=Haskell]{message_broadcast.hs}
As previously stated ID=0 represents the harness, messages sent to this ID are printed to an output file, output is also achieved in InterDyne by storing all messages of type Datamessage, which are saved to a different file then those sent to ID=0.\\  
As mentioned earlier InterDyne allows for both a topology of allowed interactions and delays along interaction paths to be defined. This can be done by passing two runtime arguments to the ``sim'' function \footnote{Both the arguments must be given.}, (i) a function that when given two agent IDs will return a delay for the interaction between them in time steps, and (ii) the maximum delay that returned by this function, i.e. the maximum delay present in the system. The previous example expanded with delays is shown here: 
\lstinputlisting[language=Haskell]{interdynewithdelays.hs}
Once delays have been specified in this manner all messages, one-to-one and broadcast, are delayed by the stated amounts between the defined agents. Dynamic delays are not shown here, but are achieved with use of another agent acting as a go between \cite{Chris_webPage}. 
 

\subsection{Work on Step-by-Step Transformation}
\begin{itemize}
  \item work by other people on step-by-step transformation and how it relates 
\end{itemize}






%\subsection{Examples}


%Day and Huang [Day, R. And Huang, W., ?Bulls, Bears and Market Sheep?, Jourmal of Economic Behaviour and Organisation, 1990] for example have demonstrated how interactions between two simple but different trading strategies and a market-maker can cause complex emergent features of stock market prices such as alternating periods of rising (?bull market?) and falling (?bear market?) with sudden switching between the two at irregular intervals. Further, Lyons [Lyons, R.K. ?A Simultaneous Trade Model of the Foreign Exchange Hot Potato?, Journal of International Economics 42 (1997) 275?298] has shown how a feedback loop can emerge between foreign exchange dealers, causing them to repeatedly transfer inventory between themselves.  Yet these are simple models of interaction.  Our aim is to develop a framework for modelling and analysing more complex emergent behaviour that arises from the dynamics of interaction, and in the context of our case study to analyse behaviour that may increase risk to the stability of the financial markets.

%\subsubsection{Hot Potato} 
%what is hot potato
%fx market

%this is a dynamic feedback loop
%how is it caused 
%when has it happened 

%what is a hft (probably need a subsectuion on this)
	%how do they work
	%what do they do
	%market makers
	%inventory limits
	%why do simple versions of them still work

%This feedback effect has been shown, in the InterDyne simulator, to create instabilities in market prices and even lead to crashes~\cite{DynamicCoupling_Chris}.   






%\subsubsection{Flash Crash}
%lob version of hot potato
 
%what is the flash crash
%when have they happned 
%other theories to why they happen?
%what we think causes them
	%emergence from feedback loops in hfts
%why they are important
%A flash crash is defined as a quick drop and then recovery in securities prices, with the most infamous  crash occurring on the 6th of May 2010 and lasting for around 20 minutes in which time almost one trillion dollars of market value was lost~\cite{Vikram_Paper}.\\
%There is no consensus on the exact cause of the flash crash, however a number of theories exist. The theory that InterDyne models is that the flash crash was caused by an interaction effect between High Frequency Trader Market Makers, known as the hot potato effect~\cite{Elias_Paper}. 



%There are numerous examples of emergent behaviour in the financial markets caused by interaction dynamics within the SoS, here we will look at how the US markets ?Flash Crash? of May 6th 2010 [CFTC-SEC, 2010. ?Findings regarding the market events of May 6, 2010?] may have been caused by these interaction dynamics. 
%The term ?Flash Crash? here is used to describe an event within a financial market where the price of commodities plummets extremely quickly before rapidly rebounding. This kind of behaviour tends to go hand and hand with commodities becoming disconnected from their fundamental value, such as stocks for companies trading at far lower prices despite the fact that mothering has change about the company in question.
%The crash in question occurred within the E-mini S&P 500 market, EXPLAIN WHAT THIS MARKET IS, lasting approximately thirty minutes [REF] with the prices for some stocks falling as low as a penny a share [REF].
%FIGURE OF FLASH CRASH??? 
%There has been a large amount of speculation about the cause of this crash with blame levelled at a large sale by a mutual fund, spoofing by a independent trader and the hot potato effect between High Frequency Traders (HFTs), it is the later that we are interested in here.
%HFTs are algorithmic traders who use equipment that allows them to operate at nanosecond speeds [REF], this means huge amounts of trading can occur between HFTs before a human can process what has happened.  Not sure how to phrase this but want to say that a lot can go wrong before a human realises 
%HFTs often operate as a Market Maker, these are entities that both buy and sell with the market under a set of rules, such as having to always have a bid and ask on the order book, they are then rewarded by having discounts applied to their trades. Market Makers make their profit of the difference in price between buying and selling assets and not of the fluctuation in price of an asset over time. They would not buy assets with the aim of selling them in a few days as they think the price would increase, instead they buy and sell the assets normally within a few milliseconds. As such having a large inventory of any asset is considered to be risky by the Market Maker and they will normally have thresholds on their stock, if these thresholds are passed, they have more stock then they want, they will enter an aggressive selling phase, quickly reducing their stock back below their thresholds. When this occurs the HFT is said to be in a panic state, the inventory at which this panic state occurs can be dynamic, changing demanding on the perceived risk within the market and how the Market Maker is trying to preform. 
%Since HFTs can place orders so quickly and make their profit of buying and selling they will normally have orders near or at the touch, the best bid and ask. This means that if you trade on the market you are likely to execute your trade with a market maker first SAY WHAT PERCENTAGE OF TRADES THE MARKET MAKERS ARE RESPONSIBLE FOR [REF]. This means that if a Market Maker goes into panic it is likely to sell its stock to another Market Maker; this creates links between the Market Makers as they will buy and sell to each other during panic states.  
%There are a number of methods used for exiting a panic state, enough inventory can be solid to bring the Market Maker back to exactly its limit, more can be solid to bring it below its limit by a set amount or all the inventory can be solid to reduce the risk to the Market Maker to zero. Each of these different options changes how much stock will be passed on to another Market Maker during the panic state.
%The question then arises, what happens if the Market Maker who buys this excesses stock is already near its inventory limit? In this case the receiving Market Maker can also enter panic, causing it to sell its inventory back to the market. As can be imagined in the right market conditions, this inventory can be picked up by another Market Maker who is also close to their limit and hence the processes can continue. If this inventory passing between the Market Makers forms a feed bank loop, where the initial Market Maker receives the stock again before selling it on for a second time, it can be said that ?Hot Potato? effect is occurring, this is simply the processes of passing inventory around traders in a loop.    
%There are a number of reason a Market Maker could be near its limits or go into panic, it could be already near its limits and then be forced to buy more inventory by the exchange rules. It could dynamically shift its risk limits changing its inventory boundaries causing it to go into panic or at least approach its limits or it could make a number of assumptions about its sell orders which may be incorrect. 
%A reason assumption are made is because of time delays with in the system. 






\section {Description and Analysis of the Problem} \label{despriptionandanalysproblem}
\begin{itemize}
  \item Introduce the idea that agent based models and InterDyne have flaws
  \item Say that though they have been used for experiments their results are not always accepted 
  \item Explain the layout of this section 
\end{itemize}


%desciption an analysis
%what is the problem, why is it important, why is difficult
%in intro and alaysis state how different the interdyne and recurrance relations are  
Though InterDyne is a functional simulation platform and has been used to run a number of experiments, most notably in Ref.~\cite{DynamicCoupling_Chris} where a model was presented showing a flash crash caused by interaction dynamics, it possesses a concern when discussing these results, especially to non-experts in computational modelling.\\
This section will discuss the main draw backs of InterDyne and a method for countering them.  


\subsection{Why InterDyne is Not Enough} \label{Iinterdynenotenough}

\begin{itemize}
  \item Say why agent based model and Interdyne are not always accepted
  \item list the down side of agent based models \begin{itemize}
  \item inverse function problem
  \item tracking parameter effects
  \item model as a whole lacking formal definition 
\end{itemize}
  \item Explain this issues in detail 
  \item Mention positive of ABM, such as easier to track messages and hence emergence and good for dynamic analysis 
\end{itemize}

As already mentioned InterDyne is an agent-based model and hence possesses the same limitations as do other models of this type. A number of these limitations are of particular concern to economists, making agent-based models and their results not commonly accepted by them~\cite{econmistsnoabm, lob_noecomimists}. The most significant limitations  with this models are:
 \begin{enumerate}
  \item Producing high-level behaviour or emergent behaviour from a set of base rules, only shows that those create it and does not show that those are the only rules that could exhibit this behaviour. This is often referred to as the inverse function problem.
  \item Tracking the affect of an input parameter on the output of the agent-based model can be very difficult, and parameter-estimation may be done in a fashion that will not represent all of the possible outcomes of the model. 
  \item Despite each agent within a simulation being fully specified the model as a whole will lack a formal definition. 
\end{enumerate}
The first limitation is shared by man modelling techniques and is a by product of studying emergent behaviour, more then one scenario may lead to the same emergence. This limitation should be considered more as a consideration when analysing results from experimentation, it is generally speaking useful to find a set of conditions that lead to an emergent behaviour, but should be noted that it can not be said that it is the only one without further research.\\
The second limitation can be reduced by analysis of the sensitivity of the outcomes to parameter selections, this is shown in Ref.~\cite{econmistsnoabm}.\\
The third limitation is of particular interest, though the other limitations can lead to questions of the validity of findings from agent-based models, the understanding of the actual model and experiment being undertaken is hindered by this limitation. A resolution to this problem was put forward by Ref.~\cite{econmistsnoabm}, in which a formal definition of the specification of the an agent-based model was given in terms of a set of recurrence relations. This solution not only provides a formal definition of an agent-based model but also does so in a way which is relatable to non-programmers, such as economists.     

\subsection{Two Views Approach} 

\begin{itemize}
  \item What is Two-Views
  \item why have two-views: \begin{itemize}
  \item its a way of being able to look from two perspectives, good for hypotheses formalisation 
  \item an intro into ABM for economists
  \item can provide more faith in ABM 
  \item Communication tool between fields (science and economics)
\end{itemize}
  \item Difficulties in two-views: \begin{itemize}
  \item two paradigms are completely different
  \item Differences between function calls and messages
  \item name control, in a way that allows for a useful and tangible ABM
  \item Show problem as a whole despite splintering
\end{itemize}
  \item explain benefits and difficulties in detail 
\end{itemize}

As can be seen from the previous discussions neither agent-based models, in the form of InterDyne, or recurrence relations offer an optimal modelling technique whose results can be analysed to the level desired. With InterDyne suffering from a lack of a formal definition and difficulties for static analysis, and recurrence relations being unsuitable to preform dynamic analyses on. Looking at the benefits of the two techniques, InterDyne is well suited to dynamic analyses, and recurrence relations provided a formal definition and are appropriate for static analyses, one can see that they match each others draw backs.\\ 
Therefore a more ideal model, would be representable in both recurrence relations and as an agent-based model.  This model would be suited to both static analyses, while expressed as recurrence relations, and dynamic analyses, when in the form of an agent-based model. A model that can correctly transform between a set of recurrence relations and an agent-based model, would provide the agent-based model with a formal definition in the form of the recurrence relations. This method will be referred to as the two views approach, with recurrence relations, and agent-based modelling seen as two complementary views of the same system.\\
To create a model tool which will allow for the two views approach, three aspects most be covered, an agent-based model,the recurrence relations, and a convertor for transforming between them. The agent-based model as already been created in the form of InterDyne and as already discussed fulfils all the needed requirements for the systems being modelled. The latter two aspects however have not been previously produced and will be the focus of this paper.      


\section{Bespoke Recurrence Relation Language}

\begin{itemize}
  \item Introduce this as the RR that are going to be used for the conversition
  \item why use a custom language? need to restrict the user enough to make the language comparable to Lambda calculus while maintaining all needed functionality, easiest to do this with own language, also need know full definition of language for parsing 
  \item what functionality does the language have? 
\end{itemize}


Recurrence relations are used across a wide range of disciplines and as such have many different forms of notation, since these recurrence relations are going to act as an import for the convertor program, having a wide range of possibly conflicting notations is not ideal. Therefore it was decided that a bespoke notation for the recurrence relation input should be used, this language will force recurrence relations to be written in a set form for input into the convertor.\\
In designing this language a few main considerations had to be taken into account:    
\begin{enumerate}
  \item The language needs to be able be both understood by and written by non-computer scientists, such as economists and mathematicians. 
  \item The language needs to be as simple as possible, to keep it easy to formally define and learn.
  \item The language still needs to contain enough functionality to fully specify the problems being modelled.
\end{enumerate}
The first consideration is taken into account by choosing the language to based in a more mathematical style then one that heavily relays on a computational style.%not sure about this sentence
The second and third consideration go hand in hand, requiring that the functionality of the language be as simple as possible while still allowing for the problem to be expressed. As such it is pertinent to decide what functionality is required by the language, this functionality is:      
\begin{itemize}
  \item The use of basic mathematical operations.
  \item The use of lists.
  \item The ability to call the head of a list. %hd
  \item The ability to call the tail of a list. %tl
  \item The ability to add to the head of a list. %:
  \item The ability to declare variables.  
  \item The ability to define a unique name for each recurrence relation.
  \item The ability to define a recurrence relation that uses inputs.
  \item The use of where blocks.
  \item The use of if else statements. 
  \item The ability to specify an entire experiment and initial conditions.  
\end{itemize}
It was decided that this language would be created by using an already existing coding language and reducing its functionality down to what was required. This resulted in the recurrence relation language being a simplified version of the Miranda language, Miranda was chosen as it is a functional language whose structure is similar to that of a set of mathematical equations, hence making it easier to adapt for use by non-domain experts.   

\subsection{Syntax}
%write this in a formal syntax as well BNF

\begin{itemize}
  \item show the formalised syntax of the language here   (neaten this up a lot)
  \item explain the syntax  
\end{itemize}


\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{Syntax_Def.lit.m}
	\caption{\it Simple example of recurrence relations written in custom defined language.}
	\label{fig:parsetreecode}
\end{figure} 


\subsection{Rules of Use}
%any function can access any other fucntion within the same agent at the current time (or passed times) but any function in a different agent can only acess at earliest one time step ago.

\begin{itemize}
  \item Explain how to write something in this language and what the language can and cannot do in more detail 
\end{itemize}

\subsection{Example of Use}
%incude that t is a key word and needs to go at the begining of timevarying reccruance relations eg t1_inv t a b c = ..
%Syntax of the functionality, how do you write all the different elements 
%t is special means time 
%c_ is used as a way of dealing with names/custome types (can not call functions)
%varbiles are just that and cant call fucntions


\begin{itemize}
  \item Show and explain an example of the language (some explain that will be converted) 
\end{itemize}

Here the syntax for the above listed functionality will be explained, in ordered of listing.\\
Basic mathematical operations are allowed, plus $+$, minus $-$, times $*$, divide \textbackslash. The ability to make comments that will not be read is also allowed, a comment is started with ``\textbackslash\textbackslash'' and then the rest of the line is ignored.\\ 
The main method for storing and transferring information between recurrence relations will be in the form of lists, lists follow the same rules stipulated by the Miranda language. A list can be created by putting the elements in side ``[]'' and separating them with a comma, allowing lists to be written in forms similar to:
\lstinputlisting[language=Miranda]{exp_list_variations.m}
However all elements in these lists must be of the same type.\\
The head of a list will be extractable using the command $hd$, this will return the first element of a list, for example $hd$ called on the list $[1,2,3]$ would return $1$. Similarly the tail of a list can be called using $tl$, for example calling $tl$ on $[1,2,3]$ would return $3$.\\  
Elements can be added to a list using the command $:$, this can be applied in the form $4:[1,2,3] = [4,1,2,3]$.\\
Variables can be declared in the language, these are names that are attached to fixed values, and can be written in the form: 
\lstinputlisting[language=Miranda]{expl_varibles.m}
A variable name must state with the identifier $c\_$, this indicates that the object is a constant, this underscore is then followed by the unique name of the variable, an equals, and then the value to which the variable refers.\\   
A recurrence relation is defined in a similar way to a variable, but can take inputs and represents a function:
\lstinputlisting[language=Miranda]{expl_simplerecurrance.m}
The name must state with a identifier of what agent, $agent\_$, this recurrence relation belongs to, in this language all recurrence relations belong to an agent. A group of recurrence relations that belong to an agent will interact with each other but only have a single recurrence relation that interacts with a different agent, group of recurrence relations. After the agent identifier, the unique name of that recurrence relation within the agent is given, recurrence relations belonging to different agents may have the same name but with an agent the name must be unique. Then the inputs for this recurrence relation are given, there may be one or more inputs\footnote{A recurrence relation with no inputs is just a variable.} separated with a space between them. Then after the equals the function for the recurrence relation is give, this function may call on other recurrence relations.\\
A where block is used to define functions and variables unique to a certain recurrence relation, one can be written as follows:
\lstinputlisting[language=Miranda]{expl_whereblocks.m}
Inside a $where$ block which is identified by ${}$ any number of functions and variables can be defined, with each new one appearing on a new line.\\
This language facilitates the use of if else statements, this allows for different behaviour based on the inputs to the recurrence relation, this can be written in the form:
\lstinputlisting[language=Miranda]{expl_ifelse.m}
Using the command $myif$ declares that an if else statement is being used, then within brackets the condition for the if statement is given, this can use $<, >, \leq, \geq, =,$ etc. If this statement is true then the $then$ part of the statement is executed, if this is false the $else$ part is used.\\
 An experiment can be defined with initial conditions in the following way:
\lstinputlisting[language=Miranda]{exp_layout_gen.m}
The design of this is one where the $where$ block contains all the definitions for the recurrence relations in the experiment. Above this the $main$ defines an experiment to run, such as a recurrence relation that you want to iterate ten times. The initial conditions are defined above this, these can have multiple different values depending on an input parameter. At the top $run\_main$ gives a list of the $main$ with different values of $runnumber$ which corresponds to different values of the initial conditions.\\
 



%what the new language looks like 
%what each bit means
%what is allowed to be written
%how to write certain things
%how is it user friendly
%why this was choosen, for example easier to convert to lambda calcualse 

%\subsection{Examples}
%examples on how to use the grammar


\lstinputlisting[language=Miranda]{inv_code_simpleexample.m}

tuples exist but can not be used by the user 
%a very simple example on the use of the grammar
%\subsubsection{Complex Example}
%what I have actually done maybe?





\section{Recurrence Relation to InterDyne Converter} 

\begin{itemize}
  \item Re say what the convertor is and what is meant to do
  \item Re say project scope and that here the converter is only being designed 
  \item say that is takes a step by step approach and why 
  \item why? so that the steps can be shown to be correctness preserving later more easily 
  \item say what the steps are going to be 
\end{itemize}

%defines the design of each step in the conversion between recurrance relations and interdyne 

%how I will create the two views
%what the converter is meant to do


%how would this work? correctness preserving transformation 

% Eventually, we would like to be able to express the System of Systems as a set of recurrence relations and then generate the agent-based model automatically; if this could be done in a way that preserves the semantics of the specification, then we would be confident that the static and dynamic analyses are being performed on models of the same System of Systems. 

This section details the design of the transformation from a set of recurrence relations written in the previously discussed custom language into an InterDyne simulation. This transformation processes  as been split into a number of smaller steps, with each step taking the expression of the system given by the previous step and modifying it to be closer to the InterDyne formalisation.\\
The transformation has been split into small steps to avoid any large jumps in logic between different representations. Jumps in logic can make it difficult to follow the transformation and more challenging to prove the correctness of the transformation.\\
The aim of this section is to show the design of each of these transformative steps, and not to implement them into code or prove their correctness, however in some case the code may also be shown.\\
To assist in the explanation of the transformation a simple example will be used through out this section Recurrence Relation Example 1 (RRE1), this example is shown in Fig.~\ref{fig:rre1}. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRE1.m}
	\caption{\it Simple example of recurrence relations written in custom defined language.}
	\label{fig:rre1}
\end{figure} 

\subsection{Recurrence Relation Parser}
%explain what the parser is and how it works, in preparing these files for transfermation

%programs wirtten in this language will be parsed into lexemes and then converted into a numeric type (?) which will be used to transfer this into lambda calcus and an ABM model



The recurrence relations shown in Fig.~\ref{fig:rre1} are text, and hence the first step in transforming them is to give them a representation within code. This is done by a parser in two parts, lexical analysis and syntax analysis.\\
Lexical analysis takes in the text file as a list of characters and converts this to a list of tokens representing items, such as function names.\\
Syntax analysis takes this list of tokens and stores it in a parse tree that enforces structure. This parse tree can be seen in Fig.~\ref{fig:parsetree}.  
 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{eparsetree.m}
	\caption{\it Simple example of recurrence relations written in custom defined language.}
	\label{fig:parsetree}
\end{figure} 


\subsection{Infinite List Outputs}
%no time as a input
%use ! to refrence the list items

%all functions turned into lists
%all fucntions now contain time (even if its the same output at all time steps)
%enforce that if time is used it has to be the first argument 
%enforce all functions take t as their first agrument whether or not they use it
%when calling a fucntion that doesnt take time can just use t, or 0 

%This is done by knowing that t is a special character that goes at the begging of time dependent recurrence relations. Therefore %function: RR t a b c = f t a b c goes to RR a b c = [ expr t a b c | t <- [0..]] where expr t a b c = f t a b c 


%done need to write up

%creates a sub wrapper that gives infitie list outputs
%all calls now need to index into this 


A large difference between recurrence relations and InterDyne, is that in InterDyne communication is done using list, and not function calls. These lists are infinite, with a each element representing a value at a different time step. Though these lists are infinite in practice they are only as long as the highest time reached, as values for any time after this are not needed and hence will not be calculated. To make the recurrence relations have a similar approach to this a wrapper function for each relation needs to be made, this function will produce a infinite list containing the value of the relation at each time step, this wrapper can be seen in Fig.\ref{fig:iloc}. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{ILOC.m}
	\caption{\it Simple example of recurrence relations written in custom defined language.}
	\label{fig:iloc}
\end{figure} 
To access a value for a particular time of a relation, the bang operator, !, now has to be used. This operator applied to a list will return a specified element of the list, for example in $List!n$ the $n^{th}$ element will be returned. 
%\colorbox{blue}{\lstinline[basicstyle=\ttfamily\color{white}]|List!n|}?  
Therefore the experiment will now be written in the form shown in Fig.\ref{fig:RRiloc}. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRiloc2.m}
	\caption{\it Recurrence relations with with infinite list outputs.}
	\label{fig:RRiloc}
\end{figure} 
       

\subsection{Wrapper Function}
%group into agents
%create a wrapper agent that out puts a infinite list (in time) containing a list of the value of each RR in the wrapper for that time step
%[[rr1_t1,rr2_t2...], [rr1_t2, rr2_t2....], ..]
%other RR now have to call the outputs using !! and by referencing the wrapper
%agent na is reserved 
%external function calls refering to fucntions of the same agent have been turned into internal function calls 

%done need to write up 

%moves the functions into agents
%outputs a infite list in time with each item being a list of all outputs from the wrapper
%all calls now index into this 


\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRwfc3.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRwfc}
\end{figure} 


\subsection{Outputs}

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRopts4.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRopts}
\end{figure} 

\subsection{Messages}

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRmes5.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRmes5}
\end{figure} 

\subsection{Queues}


\subsection{Harness}
%create the harness, that takes all the lists from the different wrappers and compiles them into one list which is passed to each wrapper as an input
%this is a finite list, with each element being a difffernt wrapper
%each wrapper is an infinite list with each element being the outputs at the time step
%the outputs at the time step are a list of the values for each RR at that time

%done need to write up 


%takes wrapper out puts, list of all wrappers?
%spreads the outputs across time to create a output list that is finite 
%wrapper functions now access the harness
%take hd of data from the harness 
%wrapper function now loops 
%delay queue to access further back in time values 
%empty list input for first element of the harnesses output 
%output message

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRhc7.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRhc}
\end{figure} 

\subsection{Input Messages}
%where an agent gets a list of messages to read 

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRim8.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRim}
\end{figure} 

\subsection{Direct Messages}
%to from messsages
%use of keys and values 

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRdm9.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRdm}
\end{figure} 

\subsection{Output Message}

%add a message telling the harness to output the write value 

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRom10.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRom}
\end{figure} 

\subsection{Broadcast Messages}

\section{Validation}

\begin{itemize}
  \item What is the validation for? checking that the conversion actual matches with an ABM (in this case InterDyne)
  \item do this by comparing types 
  \item also by checking coding syntax 
\end{itemize}

\subsection{Type Comparison to InterDyne}
%make sure agents are of type Agent_t

\subsection{Conversion to Haskell}
%output the wrappers and logic as haskell code that can then be run in Interdyne 

\section{Testing}

\begin{itemize}
  \item checking that this conversion still produces the same results as the RR 
\end{itemize}

\subsection{Example 1}

\subsection{Example 2}

\subsection{Example 3}

\section{Conclusion}

%Questions

%how do I pass a list through for, values that are needed from previous time steps?
%how do I send a message for just one time?
%if I bullet point my dissertation can you read it? 
%Does a global function work in the InterDyne frame work 
%Do I need explain code, like the function map etc 
%i presume I need to explain the operation of the convertor even if it has not been written 
%Though there can be a black hole, there isn't definitely a black whole 

%to look back in time you have to pass a list contaiing those values through the recursion of the wrapper, however wont this valiate the type defintion of the wrapper?

%How should a fucntion access its own value at a previous time step? this should be by passing a list through the recursion as well?

%All fucntions within a wrapper can access all other functions within the same wrapper at time step t, but can only access functions in other wrappers at t-1
%This is needed for both functionality and makes sense when creating agents with multiple parts which can be seen to operate at the same time

%How do I send a message to the harness at this stage sense to and from dont exist?

%When to and from do exist should a subfunction a wrapper be written like

%msg = (0, id, _f1!t), if t = 3
%msg = ..., otherwise

%Is [!t]:recursion, a backwards list? does it make [...,t3,t2,t1] instead of [t1,t2,t3,...]

%Do I need another step where I make the types correct?



\subsection{Further Work}

\begin{itemize}
  \item Build code
  \item correctness proof 
\end{itemize}

%do the correctness preserving aspect of this
 
%\section{Appendix}

%\subsection{Appendix 1} %\label{Appendix_1}
%\lstinputlisting[language=C++]{AllCode_functions.cpp}


\addcontentsline{toc}{section}{References}
\bibliographystyle{unsrt}
\bibliography{MRes_Dissertation}







     
\end{document}










