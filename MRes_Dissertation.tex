\documentclass{article}

\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{gensymb}
\usepackage{caption}
\usepackage{geometry}
\usepackage{cite}

\DeclareMathOperator{\sech}{sech}
\DeclareMathOperator{\Tr}{Tr}

\usepackage{listings}
\usepackage{color}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

%\usepackage{minted}
%\begin{minted}{haskell}
 
\lstset{style=mystyle}





\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
	{-2.5ex\@plus -1ex \@minus -.25ex}%
	{1.25ex \@plus .25ex}%
	{\normalfont\normalsize\bfseries}}
\makeatother
\setcounter{secnumdepth}{4} % how many sectioning levels to assign numbers to
\setcounter{tocdepth}{4}    % how many sectioning levels to show in ToC in preamble





\geometry
{
  %body={6.5in, 8.5in},
  left=1.0in,
  top=1.25in
}

\setlength{\parindent}{10ex}









%\begin{figure}[H]
%	\centering
%	\includegraphics[scale=0.2]{rhul_logo}
%\end{figure}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Re-Write intro

%Re-Write Background, example emergence so it feels less like an aside. Give enough detail of Interdyne that it can be used later when creting the transfromation desgin 

%Add to the description and alays what the challanges are 

%Write RR langauge section 

%Write Convertor section 

%Write Validation

%Wrtie test 

%Write Conclusion and further work 







%increase margin size! 
%abm dynamic, and RR analytic (not top down and bottom up) well abm are bottom up but rr may not be top down 
\begin{document} 
\title{Translating from First Order Recurrence Relations to an Agent-Based Representation} 
\author{Leo Carlos-Sandberg\\
Supervisor: Dr Christopher D. Clack} 
\maketitle 

\begin{abstract}
\noindent {\it 
%move two-views to later one, (if you say we will use two views (no -), two-views approach)
%start talking about, the ability to translate from one view point to another to demsotrate their equilvnece
%and why are we translating  
This paper investigates a method of describing interacting systems from two opposing view points, recurrence relations and agent-based models. These two methods take fundamentally different approaches with recurrence relations being top-down, and agent-based models being bottom-up.\\
Connecting these two methods allows for a more complete investigation of emergent behaviour occurring within interacting systems. Agent-based models offer an attractive way of analysing emergent behaviour, with the ability to investigate individual interactions as message passing throughout a simulation. Agent-based models however tend to be less well understood and accepted by those outside computer science, this is in contrast to recurrence relation which are normally well understood. Creating a correctness preserving link between recurrence relations and agent-based models allows for simulations to be understood in their recurrence relation representation and hence have their agent-based model representation accepted. This is important in fields such as finance as it opens up new tools for economists and regulators to use in understanding emergence in complex markets.\\
This research comprises the definition of a simple recurrence relation language, to define simulations, and the design of a step-by-step process by which a set of recurrence relations defined in this language can be converted into an agent-based model representation, the InterDyne simulator is chosen as a target representation for this transformation. 

}
\end{abstract}




\newpage
\newgeometry{top = 2cm}
\tableofcontents
{\textit{ }}
\restoregeometry
\newpage



%\begin{figure}[H]
%	\centering
%	\includegraphics[scale=0.5]{spin_on_lattice}
%	\caption{\it The two-dimensional Ising model lattice.}
%	\label{fig:spins_on_lattice_demo}
%\end{figure} 

%\begin{equation}
%E = -J\sum_{\langle i,j \rangle}^{N} s_{i}s_{j} - h \sum_{i = 1}^{N} s_{i}.
%\end{equation}

%\label{1d_code}

%~\cite{GouldBook} 
%~\ref{s_the_ising_model} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
Complex systems have been an area of interest for a long time in many  fields such as physics, biology and chemistry [REFS????]. %get very very old reference to this 
 More recently this is true in the fields of economics and finance [REFS?????], especially as the financial markets have become increasingly automated and interconnected. 
%These systems can exhibit unexpected and hard to predict behaviour, known as emergence, which can some times, have a large impact and damage a system.\\ 
Of particular interest is emergent behaviour in complex systems given by name "".
% not this any more (These systems can exhibit behaviour that is unexpected  and hard to predict, and which can have a large impact and  cause damage. )
%define emergence (very short) from chapter fromm 2005 types and forms of emergence (arxiv preprint nlin/0506028)  
 %hard to predict because it cant be reduced down to the definition of the compent parts 
 %page 3 top in fromm paper 2.1 is a definition (check his references reference all three) 
 
Emergent behaviour can occur in a large number of ways, but more often the behaviour of interest is created over a time period. In general there are two ways of viewing systems in time, these are either continuous (where the system progress through time smoothly) or discrete (where the system takes equal quantised steps through time, with each step advancing the system).

For discrete time systems two particular modelling techniques that can be used are, recurrence relations and agent-based models. %These two methods take fundamentally different views of a system, recurrence relations take a top down view and can be seen as a set of mathematical equations which make calls for the values of each other. Agent-based models take a bottom up approach and model different elements of the system as individual agents which communicate via messages passed between each other.\\
%analytic verses dynamic approaches 

Both of these techniques have been extensively used in the modelling of complex systems, in a larger range of fields [REFS???]. %REFS????
Recurrence relations have a number of advantages such as [REFS???]:
\begin{itemize}
%  \item Being well understood in a large number of fields. 
  \item Giving a formal mathematical definition of the whole system.
  \item Showing an obvious link between equations within the system. 
  \item Giving a static representation of the system.  
\end{itemize}
Agent-based modelling benefits include [REFS???]:
\begin{itemize}
  \item Being able to encode unique agents, with varying levels of complexity.
  \item Giving a dynamic representation of the system's evolution. 
  \item Plainly showing the passing of information between agents.
  \item Easily expandable by adding more agents.  
\end{itemize}          
The ability of agent-based models to track the communication between agents and their bottom up approach makes them particularly adept at analysing emergent behaviour. 

As mentioned there has been a growing interest into complex systems and emergence in finance, a large part of this interest is on regulating these systems to stop the creation of destructive emergent behaviour [REFS????]. This has been especially true when looking at high-frequency trading, which has been accused of causing a number of negative effects within the markets, including flash crashes [REFS???]. 
%This trading takes place at high speeds comparable to the ticks on a computers internal clock, meaning models of this type of trading typically will take a discrete time approach.\\
%just say computer trading is discrete (use chapter for help)

Though both agent-based models and recurrence relations have been used within finance, there is a notable preference among researchers grounded in economics to use recurrence relations.\footnote{This is discussed further in Section~\ref{litreviewofabmrr}.} This preference appears to be caused by agent-based models not resonating with these researchers, 
%leading to them passing over using the models as well as results be other researchers using the models being less widely accepted.\\
%rewrite this sentence break it up

%break this sentence up 
This lack of acceptance presents a problem for work on emergence within the financial system; agent-based models are a strong tool in investigating emergent behaviour, ignoring them seriously limit the ability to research this area, and a large amount of research has already been done in this area using agent-based model, if this work is only accepted by a subsection of the community its impact will be substantially lessened.     

This paper seeks to present a method whereby agent-based models will resonate better with experts such as economists, and with the hope that they will be used more frequently and the research based upon them will be better accepted.   

%be a political, dont get at econmimist at all just talk about the two different models and how 
This raises the question, how can agent-based models be explained to a sceptic in such a way that they will accept them? This papers approach is to connect agent-based models and recurrence relations together, allowing the already accepted recurrence relations to become the formalism of the agent-based model.

For this approach to work, there has to be confidence that the connection between the recurrence relations and agent-based model, has a significance and is correct. Hence the next question is what is a meaningful connect? A correctness preserving transformation was chosen as a connection, allowing the recurrence relations and agent-based model to be two views of the same system, hence giving meaning to the agent-based model of the system in terms of recurrence relations. This approach is coined as the two views.     

This transformation takes a set of recurrence relations and turns them into an agent-based model, this direction has been chosen opposed to the reverse as the aim is to encourage sceptics to engage with agent-based models, so allows them to start with the familiar before the transformation. 

To achieve this transformation from a set of recurrence relations to a agent-based model, a number of conceptual challenges needed to be addressed. These problems are discussed in greater depth in Section~\ref{twoviewsapproach} but including: 
\begin{itemize}
   \item The two paradigms of the models are completely different and opposing. 
   \item How are function calls related to message passing?
   \item How can the idea of agents having a infinite list through out time of their values be derived from the recurrence relations? 
   \item How can the idea of private and public information introduced, and what data should fall into each category? 
   \item How can public broadcast data be introduce, and what data classifies to be treated as such? 
   \item How can time limited information be introduced?
   \item How can name control be introduced in a tangible way into a recurrence relations that have no notion of agents. 
   \item How can output messages containing message information be introduced? 
   \item How can the recurrence relations be split in a way which does not splinter the model? 
   \item How can small, and hence more susceptible to prove of correctness, steps be used to transform the model? 
\end{itemize}
To create a transformation that allows these issues to be overcome and to increase the easy in proofing the correctness of this conversion, a step-by-step approach was taken, where the transformation is done in a series of small correctness preserving steps. 

This papers aim is hence to create the design of each of these steps, in the process of transforming from a set of recurrence relations to an agent-based model.

Creating this transformative method has  two important aspects, increasing the acceptance of agent-based models and creating a model for viewing systems in two perspectives. Increasing the acceptance of agent-based models has a number of benefits including: 
\begin{itemize}
   \item Increasing the use of agent-based models in new research, where their benefits would be more suited. Hence increasing the ease in which emergence can be investigated within the financial system. 
   \item Allow for work already done using agent-based models to be re-evaluated with a greater understanding to the methods used. 
\end{itemize}
The creation of the two views model always a number of unique benefits by providing a new tool for analyse of complex systems: 
 \begin{itemize}
    \item Adds a new technique for viewing and modelling complex systems.
    \item Adds a new tool that can be used for hypotheses formalisation and communication of ideas between researchers. 
    \item Adds a model that is suitable for both static and dynamic analyses. 
 \end{itemize}
The timing of this paper fits with the increased interest in agent-based models within finance, for modelling the complex behaviour of the markets [REFS???????]. %REFS????
This work is designed to be able to support other work done using agent-based models and help further the understanding of agent-based models during this time of interest.

To show a conversion between the two types of models a particular example of each must be chosen, for this paper a custom recurrence relation language was designed to be transformed into the agent-based model known as InterDyne. InterDyne was chosen in particular due to it being designed from the bottom up to model and investigate emergent behaviour within the financial markets, this software was also a convenient choice due to access to the source code and local expertise.   

This papers layout is as follows. First a background is given detailing, emergent behaviour generally and in the financial markets, a description and review of the literature of both recurrence relations and agent-based models, and a in-depth description of InterDyne. Secondly a description and analysis of the problems with agent-based models and how a two-view approach addresses them. Thirdly a description of the design, formal syntax, and use, of the custom recurrence relation language. Fourthly the design and a example of the step-by-step transformation between the two models. Fifthly a validation that the transformed example does indeed represent a InterDyne simulation. Sixthly a test of a number of examples for correctness of functionality. Lastly the paper is concluded and summarised with notes for further work given.     
%This connection between the models is coined as the two-views approach.\\



%regulation is shifting from micro to macro-prudential perspective 
%managing individual risk to managing systemic risk

%USE THIS LINK
%\cite{fallacyofcompostionBook}
%talks about policy due to emergence 
%page 10 
%googled "fallacy of division emergent behaviour"

%no formal description of the problem

%-DEVS model does give you overarching symatic (why is it not approate to model interarction dynamics) 



%Compare difference equations and ABM in intro using the "TO AGENT-BASED SIMULATION FROM SYSTEM DYNAMICS" paper



%in project scope: show some limited implementation. Say initial aim was to design, but not implement the translation steps. However, the project has succeeded in all of the design aims and additionally succeeded in implementing several of the translation steps."


%This makes agent-based models in many cases the most natural way for describing systems composed of ``behavioural'' entities~\cite{techsadsProbsabm}.

%In many cases, ABM is most natural for describing and simulating a system composed of ?behavioral? entities. Whether one is attempting to describe a traffic jam, the stock market, voters, or how an organization works, ABM makes the model seem closer to reality. For example, it is more natural to describe how vehicles move in a lane than to come up with the equations that govern the dynamics of the density of vehicles. Because the density equations result from the behavior of vehicles, the ABM approach will also enable the user to study aggregate properties. (from paper techsadsProbsabm)

%The flexibility of ABM can be observed along multiple dimensions. For example, it is easy to add more agents to an agent-based model. ABM also provides a natural framework for tuning the complexity of the agents: behavior, degree of rationality, ability to learn and evolve, and rules of interactions. Another dimension of flexibility is the ability to change levels of description and aggregation: one can easily play with aggregate agents, subgroups of agents, and single agents, with different levels of description coexisting in a given model. One may want to use ABM when the appropriate level of description or complexity is not known ahead of time and finding it requires some tinkering. (from paper  techsadsProbsabm)

%https://www.ijcsi.org/papers/IJCSI-9-1-3-115-119.pdf



%Abandoning the consistency requirements of RE equilibrium removes the need for solving the models as one single block: in principle AB models can be fully modularised, with endless possibilities for recombination and extension. However, this feature has not been exploited so far. Existing AB models are mostly one-off exercises which do not travel across research groups and whose ?working life? does not usually extend beyond the grant that originated them. Code is not re-used, except possibly by the authors themselves; alternative assumptions are not tested, results are not generalised. In short, knowledge accumulates at a slow pace. The reason for this ?modelling individualism?, as we might call it, is to be searched in the struggle to win the ?modelling race?, in line with existing incentives in terms of (short-term) publications and funding opportunities.
%https://www.nuffield.ox.ac.uk/economics/papers/2015/ABMfuture-v12.pdf

%https://www.ripublication.com/ijaer16/ijaerv11n8_23.pdf (says that abm might be much better then other models)


%Such methods are unfamiliar (or unappealing) to most theorists in the leading research departments and rarely published in the top professional journals. Farmer and Foley attribute this in part to the failure of a particular set of macroeconomic policies, and the resulting ascendancy of the rational expectations hypothesis:


%talk abou tht eneed for the strucutre of recurrance relations needing inital condition and driving expression 



%We want to look at emergent behaviour that comes from interaction dynamics, this relays on viewing the communication between the different components of a system as messaging passing. Agent-based models naturally support this view  making them well suited to analysing emergent behaviour. However most agent-based models do not have a well defined formalisation for the system as a whole, which makes it difficult to perform system wide analytics. 
%recurrence relations naturally suportan system wide analys, but do not support a message passing view of cummonicatiio.
%What we want is a way of viewing a system using both models, hence being able to have the benefits of being able to view the passing of information  this is the two views approach t




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}
This section covers a description of emergent behaviour, feedback loops as type of this behaviour and their appearance in the financial markets. Recurrence relations and agent-based models are introduced as a method for modelling emegernt behaviour, and they are described. InterDyne is introduced as an example of an agent-based model designed for the financial markets. Its applicability to modelling aspects of the financial market will be discussed and description of its design will also be given.   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Emergent Behaviour}
Emergent behaviour is a term used to describe macro-level behaviour of a system that is not obvious from analysis of the micro-level behaviour of the system, more formally this is behaviour that can not be predicted through analysis of any single component of a system \cite{EB_systemofsystemsGLangford}.

A misunderstanding of emergence can lead to the fallacy of division, this is that a property of the system as a whole most also be a property of an individual component of the system; water for example has a number of properties including being able to be cooled down to become ice and heated to become steam, saying the same must also be true of a molecule of water however is incorrect. This concept continues into economics, being called the fallacy of composition, where what is true for the whole economy my not hold for an individual and vice versa~\cite{fallacyofcompostionBook}.
       
A simple way to demonstrate emergence is in the Game of Life~\cite{gameoflifepage}, which is an example of cellular automaton; this game takes place on an infinite two-dimensional grid in which cells can either be `alive', coloured for example green, or `dead', a different colour usually black. Wether a cell is `alive' or `dead' is based on a set of simple rules:   
\begin{enumerate}
  \item `Alive' cells will transition to be `dead' cells in the next time step if they have few than two `alive' neighbours.
  \item `Alive' cells with two or three `alive' neighbours remain `alive' at the next time step.
  \item `Alive' cells will transition to be 'dead' cells in the next time step if they have more than three `alive' neighbours.
  \item `Dead' cells with exactly three 'alive' neighbours will transition to `alive' at the next time step.
\end{enumerate}
With this simple set up very complex patterns evolving through time can be created, these patterns can be seen as emergence, with an individual cell not being able to encapsulate this behaviour. Natural phenomena similar to this is the formation of symmetries and patterns within snowflakes.

Emergent behaviour can be seen occurring naturally in many other cases, with physics offering a number of well explored examples. For instance the n-body problem~\cite{nbodyproblem}, this historically is explained as n planets interacting in such a way as to produce complex behaviour, despite each individual body following Newtonian laws. An interesting aspect of the n-body problem is that it can be reduced down to three bodies and still exhibit complex emergent behaviour. This example shows that a system need not be overly complex or large to display emergent behaviour, and that by showing the existence of emergence in a simplistic system one can infer its presence in more complex versions of that system.

The emergent behaviour within the n-body problem is caused by interaction dynamics, this is the communication between different elements of a system. The interactions here takes the form of gravitational pulls, if these pulls were not present then the system as a whole, and every individual present would maintain a constant velocity, unless they physically collided~\cite{newtonconstantvelocity}.

Though this example deals with a physical phenomenon, interaction based emergence is present in many different systems. Interactions in these systems can take the form of verbal and visual communication in social systems with negative emergent behaviour in this case being the break down of social cooperation~\cite{socialemrgence}. The financial markets can be thought of as a complex system, with interaction dynamics, hence one can assume that the markets would exhibit emergence. This is true and the financial markets have seen to exhibit a large selection of emergent behaviour, such as the formation of patterns, bubbles and crashes~\cite{bubblesandcrashes}. These particular examples derive from feedback loops with in the markets, in a similar process to that of the interaction between short range and long range feedback loops in chemical reactions~\cite{turningchemical}.     

Feedback loops are a prominent type of emergent behaviour that can occur from interaction dynamics. Feedback loops are where the input information to an entity is in some way dependent on the output information of that same entity, normally from a previous moment in time. In their simplest form this can just be a single entity supplying an input to its self, shown in Fig.~\ref{fig:exampleselffeedback}.

In finance this could be seen as a simple trader who decides how much to sell based solely on their inventory at the previous time step. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{selffeedback}
	\caption{\it Simple feedback loop with an entity supplying its input from its output.}
	\label{fig:exampleselffeedback}
\end{figure} 
Feedback loops can be encompass multiple entities, in Fig.~\ref{fig:exampletwofeedback} a feedback loop is shown that encloses two different entities. A output from $E2$ is passed to $E3$ which in turn creates a new input for $E2$, though $E2$ input is not directly its own output, it does depend upon it. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{twofeedback}
	\caption{\it Feedback loop between two entities, with each output being transformed by the other entity before becoming an input.}
	\label{fig:exampletwofeedback}
\end{figure} 
A loop such as the one in Fig.~\ref{fig:exampletwofeedback}, is only considered a feedback loop if information is passed through out the entire loop. If $E3$ produced a constant output, or an output that does not depend upon its input from $E2$, then this would not be a feedback loop as the new input to $E2$ does not depend on its output.

These example are very simple, feedback loops can be much more complex, encompassing any number of entities, each of whom can have very complex algorithms for transforming their inputs. Feedback loops can operate across time, meaning that an event in the past can eventually feedback to a present decision. For a feedback loop containing a large number of entities the time scale on which the feedback occurs can be come significantly large.

Though feedback loops are often assumed to be a negative property, some can be stabilising due to a benign effect.

Feedback loops can be present in a system in two ways, either they can be a constant fixture, called a static feedback loop, or they can form and change, called a dynamic feedback loop. A static feedback loop is present in the system from the start whether this is intentional and known, or unintentional and unknown to the members of the system. Dynamic feedback loops may not be present at the start and can form and change over time, with new entities joining or leaving them, allowing them to increase or decrease in size or effect, to split or merge, or to disappear.

Due to the potential complexity of feedback loops both in construction and in time, they can be difficult to detect, therefore methods are usually used to expose them. For static loops, forms of static analysis can be used such as, analysing initial setup, this is possible since the loops do not change through out time. Dynamic loops can be much harder to observe and analyses, an important aspect to detecting these loops is the interactions, messages sent between different entities within the system. Since the loops can evolve over time being able to track and analyse these messages over a time series is vitally important for the analysis of these loops, this time dependent analyse is called dynamic analyse.

Since feedback loops can be destabilising and damaging to the system in which they occur, there is interest in studying this emergence in the aim to prevent monetary loss and damage to the economy.

A notable form of emergence behaviour, due to feedback loops, that takes place within the electronic markets are flash crashes. A flash crash is an event during which time the trading price of a security drops very rapidly, becoming disconnected from its fundamental, before then recovering~\cite{rareeventflashcrash}. A particularly famous flash crash is that of 2010, in which the E-min S\&P 500 equity futures market dropped in price by more then 5\%, before rebound to close to its original price~\cite{SECreport_delays, rareeventflashcrash}. This whole process occurred very rapidly, lasting approximately thirty-six minutes and has been described as``one of the most turbulent periods in their history'' for the US financial markets~\cite{Impact_hft}.

Research done by Ref~\cite{DynamicCoupling_Chris, otherabmflash}, describes how the crash may have unfolded due to a feedback loop between High-Frequency Traders (HFTs), known as `hot-potato'' trading.

HFTs are a subset of algorithmic traders who normally participate in the market as arbitrageurs or market makers, they invest in ultra-high speed technology allowing them to detect, analyses and react to market condition in nanoseconds \cite{hftinformation1}. This means HFTs can trade huge quantities of assets in very short time frames, with some estimates stating that 10-40\% of all trades where initiated by them during 2016 \cite{hftmarketparticipation}.

The feedback loop of ``Hot Potato'' trading, is when inventory imbalance is repeatedly passed between HFTs market makers. A market maker is a trader who is required to have both a bid and a ask on the order book at all times, this means in theory that they are constantly buying and selling, a high frequency market maker as expected should be buying and selling very very often. Market makers make a profit from the spread and not long positions, hence they want to keep inventories low to avoid the market moving against them. To achieve this market makers have strict inventory limits that if they pass will cause them to go into what is know as a ``panic state'', during this state the trader will sell of an amount of its inventory to return back into its normal trading region. This inventory now sold by the market maker can be bought by another market maker causing them to in turn go into ``panic'' and sell, this process is ``Hot Potato'' trading and can in theory continue indefinitely~\cite{Elias_Paper}.

This constant selling and buying of inventory can artificially inflate the trading volume of the market, changing how many traders operate and potentially leading to a flash crash.

Flash crashes have occurred on a number of occasions and in a large selection of markets, with a more recent example being a crash of the cryptocurrency ethereum~\cite{cryptocrash}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Methods for Modelling Emergent Behaviour in Finance}  \label{litreviewofabmrr} 
There are many different methods available for modelling system that may exhibit emergent behaviour, such as: 1-period, 2-period and multi-period models, probabilist models, like hidden Markov models, ordinary differential equations and partial differential equations [REFS??????]. This paper focusses on two models that can be used for discrete non-equilibrium system, recurrence relations and agent-based models. 

Both recurrence relations and agent-based models have been used in modelling the financial markets and have had a number of papers published on them.

Recurrence relations have seen wide spread use in economics appearing in a large selection of journals, including numerous times in top journals~\cite{rra10, rra1, rra2, rra3, rra4, rra5, rra6, rra7, rra8, rra9}. This wide spread use of the technique implies the acceptance of recurrence relations within financial modelling.      

Agent-based models also have a large selection of papers published on them relating to economics and finance~\cite{ abma2, abma3, abma4}. However these papers are noticeably absent from top economics journals (with some exceptions, such as Ref.\cite{abmexp1} and~\cite{abmexp2}) and tend to be published in the Journal of Economic Behavior \& Organization and the Journal of Economic Development \& Control~\cite{whereabmp, farmerfoleynature}. The lack of agent-based models present in top economic journals combined with the number of papers published in other journals shows the lack of wide spread acceptance for this technique~\cite{agbntj, econmistsnoabm, lob_noecomimists}.

Here these two modelling techniques will be described.  


\subsubsection{Recurrences Relations} 
Recurrence relations connect a discrete set of elements in a sequence, these elements are normally either numbers or functions, they can be used to define these sequences or produce the elements in them. They can be seen as equations that give the next term in a sequence based on the previous term or terms, hence defining said sequence. Recurrence relations are often used to define coefficients in series expansions, moments of weight functions, and members of families of special functions~\cite{recurrelationbook}.

The most simplistic form of a recurrence relation is one where the next term depends only on the immediately preceding term. If the $n^{th}$ element in the sequence is defined as  $x_{n}$, then this recurrence relation can be written as,    
\begin{equation}
x_{n+1} = f(x_{n}),
\end{equation}
where $f()$ is a function that calculates the next term based on the previous one. A recurrence relation does not just have to depend on its immediate previous term and can depend on any number of terms further back in the sequences, for example a recurrence relation depending on terms from two and three steps before can be written as, 
\begin{equation}
x_{n+1} = f(x_{n-1}, x_{n-2}),
\end{equation}
with $f()$ now taking two inputs to produce the new term in the sequence~\cite{recurrealtionwebpage}.

Recurrence relations can also be used to define a sequence through time, in the simplest case the enumerate $n$, can be set to represent time $t$, this is applicable to discrete time as it requires set steps between the different times. Just as in the previous examples, the simplest recurrence relation is,  
\begin{equation}
x_{t+1} = f(x_{t}),
\end{equation}
where $x_{t}$ is the term at time $t$ and $f()$ gives the term at $t+1$ based on the term at $t$. Again this can be expanded to include terms from a number of previous time steps, allowing the memory of the sequence to be shown.
 
A recurrences relation for defining a sequences may as well as depending upon previous terms, also depend upon some parameter, $\alpha$, this would give, in its simplest case, 
\begin{equation}
x_{n+1} = f(x_{n}; \alpha).
\end{equation}
The next term in the sequence may not only depend on previous terms within its own sequence and parameters, it can also be conditional on another sequence. For example one sequence through out time, $x$, may depend on another sequence through out time, $y$, a simple recurrence relation for this could be,
\begin{equation}
x_{t+1} = f(x_{t}, y_{t}),
\end{equation}
with the sequence for $y$ possibly depending on its own recurrence relation. The sequence for $x$ may not even directly depend on its own sequence and could solely depend on $y$, 
\begin{equation}
x_{t+1} = f(y_{t}).
\end{equation}
Though it could also indirectly depend on its self, if $y$ was defined by a recurrence relation depending on $x$, such as, 
\begin{equation}
y_{t+1} = f(x_{t}).
\end{equation}
These cross sequence associations allow for complex interactions to be represented as time series defined by recurrence relations.

Recurrence relations have a number of benefits given by their construction, such as:
\begin{itemize}
    \item Giving a formal mathematical definition of the whole system.
    \item Showing an obvious link between equations within the system.
    \item Giving a static representation of the system.
\end{itemize}

A formal mathematic definition of the whole system being model is given when using recurrence relations due to three factors: the way in which they model the whole system as a entity, the static view point they give to the system and the mathematical stye which they take~\cite{rrformulism}.  %is this right?

Links within sets of recurrence relations are hard coded into the equations, making these relationships amenable to static analysis.      

This model lays out both the functionality of each equation and the relation between them in such a way to give a static representation of the system as a whole. 

This model however has difficulties in design as it can be challenging in creating a large continuous description of a system containing many components, also the function calls as a method of information passing can make dynamically tracking the flow of information during a simulation hard [REFS????].   




%These cross sequence associations allow for complex interactions to be represented as time series defined by recurrence relations, this is a method which can be applied to agent-based modelling.

%Reference~\cite{econmistsnoabm} showed how an agent-based model looking at the microstructure of the financial markets, can be exhibited in the form of recurrence relations. In their approach each agent with in an $n$ agent model is considered to be well described by a state variable, $x_{i, t}$. The state variable describes the agent at each time step, where $i$ is the identity of the agent $(i \in 1,2,....,n)$, and $t$ is the time step at which the agent is being described, i.e. $x_{1,5}$ describes the first agent at the fifth time step. These state variables are defined by the recurrence relation,     
%\begin{equation} \label{eq:notimedelayrecur}
%x_{i, t+1} = f_{i}(x_{i, t}, x_{-i,t}; \alpha_{i}),
%\end{equation}
%where $f_{i}()$ is a function unique to agent $i$, that can take the state of the agent at the previous time step, $x_{i, t}$, the state of any other agent at the previous time step, $x_{-i, t}$\footnote{The $-i$ is used to refer to all other agents in the system. So if $i=1$, $-i$ refers to agents $2,3,4,....,n$, for an $n$ agent system.}, and a bespoke parameter $\alpha_{i}$.

%This method works by describing each agent as a sequence of state variables, these sequences are then interlinked by having dependencies to each other, allowing both the agents and their interactions to be represented. A simple example of this could be two agents, $x_{1}$ and $x_{2}$, that are coupled to each other and only depend on the others value at the previous time step and a parameter, represented by the recurrence relations,     
%\begin{equation}
%x_{1, t+1} = f_{1}(x_{2,t}; \alpha_{1}),
%\end{equation}
%\begin{equation}
%x_{2, t+1} = f_{2}(x_{1,t}; \alpha_{2}).
%\end{equation}
%This formulation only shows relationships to the previous time steps, however information delays can be added to the system by allowing the recurrence relations to have a longer memory. A recurrence relation that uses a state variable from three time steps ago, could be considered to have a time delay of three time steps in receiving this information. The generalisation of the model needed to allow for this, is a recurrence relation of the form, 
%\begin{equation}
%x_{i, t+1} = f_{i}(x_{i, t}, x_{i, -t} x_{-i,t}, x_{-i, -t}; \alpha_{i}).
%\end{equation}
%This is similar to Eq.~\ref{eq:notimedelayrecur} but contains two new terms $x_{i, -t}$ and $x_{-i, -t}$, these terms are used to refer to any time steps before the previous one, time $t$. This more general equation can now reference any state variable from any previous time, from any agent, as well as its bespoke parameter, to compute the next term in its sequence.
 
%This models can be solved for macro-level properties by iteratively solving each state variable, $x_{i, t}$, given some initial conditions. This method of assessing the model gives it a formal definition, and one that is accessible by a larger range of experts then classic agent-based models. Recurrence relations in a number of forms are commonly used in economics and finance and hence are familiar and relatable to economists, this makes them a far more effective tool for describing models to these domain experts then agent-based models.

%This iterative method for solving the equations makes any dependencies between systems apparent, as if $x_{2, t}$ is present in the definition of $x_{1, t+1}$, one can say that $x_{1,t+1}$ depends on $x_{2,t}$. This transparency of dependencies makes this formulation amenable to static analysis, allowing the recurrence relations to be investigated to return their static dependencies.

%Although all recurrence relations will contain some form of recursive, since this is an intrinsic property, this will not necessarily be negative or destabiliszing. For example a dependency on a state at a previous time step may not be destabilising to the system, however the reverse would be a case where the state variable at $t+1$ depended on its self, this would be a destabilising loop. Static analysis hence could be used to detect hard-wired destabilising loops, such as the one just mentioned.

%Static analyse of the system can become difficult when the functions $f_{i}()$ contain conditional statements relating to their inputs, this can cause inputs not to be used at certain times hence meaning dependencies will not be as obvious as simply the inputs given, this is a problem of determining wether a function will necessarily evaluate all its arguments~\cite{willevaluteargsa}.

%Though through static analysis recurrence relations can be used to view the history of the state variables of a single agent, however the history of messages between pairs of agents is not easily detectable with static analysis. The interaction history is found through dynamic analysis which is not well suited to recurrence relations, as they lack a clear ability to follow the passing of messages within the system.   








\subsubsection{Agent-Based Models}
A modelling technique that takes a more dynamic approach is agent-based modelling. Agent-based modelling can be considered more of a mind set then a rigid methodology, this involves describing the system in question in terms of its components and then allowing these to interact. Agent-based models allow a system to be described naturally and are hence the canonical approach to modelling emergent phenomena. This method is a bottom up approach, allowing for each component of the system, agent of the model, to be created to a relevant degree of abstraction~\cite{abmhumsystems}.

Agent-based models have been used to model a wide range of emergent behaviour including in the financial markets, examples of this are, noise traders~\cite{abmnoisetraders}, herding among traders~\cite{abmherding}, and fundamentalists~\cite{abmfundemetilists}.

Agent-based models are particularly suited to system which, contain a number of autonomous components. Each component can be modelled independently and then allowed to interact through messages sent between each other. This allows for a obvious visual design of the system, such as that shown in Fig.~\ref{fig:abmii}.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{abmii}
	\caption{\it Visualisation of the allowed interactions between five different agents, represented by black circles, with red lines representing the message paths.}
	\label{fig:abmii}
\end{figure} 
The main aspect of this model is the agents used. Though every system modelled can have drastically different agents, there are a few characteristics which should be in place for a agent to be considered an agent~\cite{MN2010, abmtsd}:
\begin{itemize}
   \item An agent is self contained, unique and identifiable, this requires an agent to have boundaries which can easily be used to determine what is and what is not part of the agent. 
   \item An agent autonomous and it can act independently during its interactions with other agents. Its has behaviour and decisions that can be associated with information acquired  during communication with other agents. 
   \item An agents state varies over time, representing variables associated with its current position. 
   \item An agent behaviour is influenced by dynamic interactions with other agents. 
\end{itemize}

This modelling technique has a number of benefits originating from its construction, these include:
\begin{itemize}
   \item Being able to independently create each agent to varying degrees of complexity. 
   \item Giving a clear visual representation of the systems interconnectedness.
   \item Giving a dynamic representation of the system.
   \item Easily expandable by adding more agents.  
\end{itemize} 

Since each agent in the system can be completely autonomous and independent from each other, save for message passing, this allows for them to be created individually. Hence each agent can describe its relevant component to a relevant degree of complexity, making the creation of a simulation more intuitive and sectioned. This makes agent-based models in many cases the most natural way for describing systems composed of ``behavioural'' entities~\cite{techsadsProbsabm}.

Do due the set up of this model the a network representing the communication between different agents is easy to construct, this allows for topologies to be visualised and can aid in the creation of a simulation.    

The use of messages and bottom up approach this model takes allows for a more dynamic view of a system to be achieved, messages can be more easily tracked through out the systems evolution allowing for events to be more easily pinpointed and analysed.  

The use of independent agents makes this technique very amenable to expansion, new agents can be added normally with little to no change to previously existing agents. This allows these simulations to be confidently expanded to look at more complex systems, or to add new elements to an existing system.  

These aspects of this approach make the modelling technique well qualified for modelling and analyse of emergent behaviour within systems of interacting components. However this approach does contain some draw backs including a one-to-many problem (where though some high level behaviour may be noted in the system this does not mean the only way of achieving this behaviour is the current system design) and the lack of a formal definition for the system as a whole [REFS???].  



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{InterDyne} \label{InterDyne_section}
An example of an agent-based model used in modelling the financial markets is InterDyne. InterDyne is bespoke simulator created by Clack and his research team at UCL~\cite{Chris_webPage}, it is a general-purpose simulator for exploring emergent behaviour and interaction dynamics within complex non-equilibrium systems.

InterDyne design is that of an agent-based model interacting via a harness. This creates a structure of individual autonomous agents who interact through messages sent through a harness to one another.
 
Similar to other agent-based models InterDyne operates in discrete-time rather then continuous time. These quantised time chunks, which move the simulation forward, can be left without proper definition (allowing operations to be defined in a number of time steps) or they can be equated to a real time (usually with the smallest time gap needed being a single time step and then all other timings being integer multiples of this). This discrete time is most important to message passing, with messages between agents are only sent on a integer time step.

Massages in InterDyne are just small packets of data, such as a series of numbers. An agent can send private messages that are only received by a single other agent (one-to-one messages), or it can send public broadcast messages received by any number of other agents, subscribed to a channel (one-to-many messages). To facilitate this a communication topology can be made for InterDyne, this is done in the form of a directed graph determining which agents can communicate with each other. Due to the directional nature of these messages this topology could allow an agent to send messages to another but not be able to receive messages from that same agent. Messages have a defined order to them, an agent will, unless otherwise instructed, always process messages in the order in which they arrive. To change the order in which messages arrive delays can be added to communication paths between agents, this can be a static delay which always applies to messages sent from one agent to another, meaning this will arrive a set number of time steps later. Or a more complex dynamic delay, which is achieved by using another agent to mediate the passing of these messages delaying by an amount decided on in some internal logic. All messages in InterDyne are passed through a harness, this does not alter the messages or delay them\footnote{Unless instructed to, using a static delay.}, but does store the messages and their order which can be used in post analyse.
        
Each of the agents within an InterDyne simulation can be completely unique and modelled to different levels of complexity, as is the case with most agent-based models. As a whole InterDyne simulations are deterministic, repeated experiments will return identical results. However non-determinism can be added via the agents, making some part of an agent stochastic will lead to repeated experiments on the whole returning different results. A pseudo-random element can also be added by instructing InterDyne to randomly sort the message order for any agent receiving multiple messages in one time step. This is only pseudo-random as, as long as the same seed is used each run of the simulation will order the rearranged messages in the same way.\footnote{If an agent receives multiple messages at the same time step and the pseudo-random element is not being used, these messages will order based on the identifiers of their sender agents.}

InterDyne is created to be particularly amenable to dynamic analyses of its simulations, this is achieved in part by all messages being sent via the harness allowing them to be stored in order.     


\subsubsection{Applicability to Finance} \label{applicabilut_to_finance}
InterDyne has been designed with modelling flash crashes in the financial markets in mind and has a number of features that make it well suited to this purpose. 

\paragraph{Deterministic}
The deterministic nature of InterDyne allows for experiments to be run multiple times with the same result always returned, this allows for changes to the experiment setup to be investigated. For example changing the number of traders in the market and comparing this to a previous run allows for an investigation into how many traders are required for emergent behaviour to be observed.

This becomes particularly interesting when comparing the interactions between market makers to that of the n-body problem. Like with this problem one could expect emergent behaviour might occur to some extent in a large group of market makers, however the question of whether emergence persists in a comparable market to the three-body problem and how this compares to a larger market can be investigated.   

\paragraph{Message Delays}
Allowing for messages to be delayed is needed to facilitate hypotheses involving delays as a factor for emergent behaviour. Delays have been suggested to have caused ``hot potato'' trading during a flash crash, these delays can exist due to processing time and transmission time of messages~\cite{SECreport_delays}.

InterDyne allows for both symmetric and asymmetric, delays. These delays can be static or dynamic, with dynamic delays requiring a special intermediary agent. 

\paragraph{Storing Messages}
InterDyne facilitates analyses of simulations be allowing for the messages between agents to be stored and viewed as a trace. This can include all messages as well as timings, messages can also be sent directly to the harness which will be added to the trace file. 
  
\paragraph{Message Ordering}
The order in which messages are processed can be very important. For example in an exchange, it can change whose limit order has priority at a given price and whose market order executes the lowest prices. Changing these factors can make or break feedback loops within the system, meaning if message ordering is not properly dealt with the correct emergent behaviour may not be observed. Hence InterDyne stores messages in the order they are received by an agent, taking into account delays to the messages. This however can not be done when multiple messages are received at the same time step, due to the nature of discrete time there is no way for the agents to know which message arrived first. Therefore two options are presented by InterDyne; messages are ordered according to their agent identifier or messages are randomised and executed in the emerging order.



\subsubsection{InterDyne Detailed Operation}
InterDyne is a written in the functional language Haskell. The structure of an InterDyne model is show in Fig.~\ref{fig:harness_setupfigure}, this structure contains a number of agents and a simulator harness. These agents send two types of messages, either one-to-one or one-to-many (broadcast) messages. Both these messages are sent to the harness, the harness then resends these messages to the appropriate agents, one-to-one messages are sent to their target agent and one-to-many messages are sent to any agent subscribed to the relevant broadcast channel. Messages can also be sent directly to the harness and not rerouted to another agent. At the end of the simulation the harness will produce a trace file containing information on all the messages sent for post-hoc analysis.    
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{harness_setup}
	\caption{\it Structure of an InterDyne simulation containing three agents. The messages sent by the agents to the harness and from the harness are coloured red. The trace file and messages sent to the trace file are coloured orange. The messages sent from the harness to the broadcast channels and then back to the agents are coloured blue~\cite{interdynemanual}.}
	\label{fig:harness_setupfigure}
\end{figure} 
%-topology and delays 
InterDyne has a intrinsic delay, which means any message sent will not be received until the next time step, message sent at $t$ will be received the earliest at $t+1$. This is in part due to the fact that the harness compiles all messages from a single time step before sending them to their targets and hence initiating the next time step. The harness can be seen as the driver in the simulation sending out the message and forcing the agents to send there next message.   

Longer delays can also be added using InterDynes topology, this allows for any two agents to be selected (a sender and a receiver) and for a delay between them to be given. This topology takes the form of a directed graph, with the agents acting as the nodes and the interaction routes as the links, this allows for the delays to be asymmetrical. Using this a delay for a path could also be set as a abort message, making a particular communication route unusable.  

Adding delays is done through run time arguments, here two run time arguments must be added, one stating the maximum delay in the system and the other listing the delays. To show the maximum delay the argument $(Arg (Str$  $``maxDelay", 10)))$ is used, where $10$ is the maximum delay. To add the list of delays the argument $(DelayArg (Str$  $``DelayArg", delay))$ is used, where $delay$ is a function that takes two agents and returns the delay between the first and the second. 
%-what a message looks like 

Messages sent between agents can in theory be as complex as needed, these messages do however have to comprise of these components: 
\begin{itemize}
   \item A tag indicating the type of message being sent, e.g. a broadcast message.
   \item A tuple of two integers, with the first being the sending agents ID and the second being either the receiving agents ID or the receiving broadcast channels ID.  
   \item The data that is being sent. 
\end{itemize}
An example of this is a one-to-one message, which would look like $Message$ $(1, 2)$ $data$, where $data$ is the information being sent from agent $1$ to agent $2$ 

A broadcast message, which looks like $Broadcastmessage$ $(3, 1)$ $broadcastdata$, can be received by agents subscribed to its channel, in this case $1$. All agent subscriptions have to be announced at the beginning of a simulation and can not be changed during it. This is done by adding the subscription channel to the list in a tuple passed as an argument, for example this could look like $(agent1, [1])$, for agent 1 subscribed to broadcast channel one.

Empty messages can also be sent, if the message is required to be known to be intentionally empty and not a mistake the a message can be sent containing ``Hiaton''. This is done at the beginning of the run to allow for the harness to send a first message. 
%-what is an agent in interdyne and what is its type

InterDyne is designed in such a way that agents both taken in and produce a seemingly infinite list of messages. This is achieved through lazy evaluation in Haskell, which in short means that any element in the list will not be calculated until it is absolutely needed. This allows for an infinite list as long as no agent tries to read further into the list then what as already been calculated. In achieving this an agent must at each time step, allows read in a message (even if it is then not used) and produce a list of messages (even if this is a empty list). An agent will hence iterate over the list of incoming messages, at each time step adding a new output message to its list of output messages.  

Agents in InterDyne are topically, though not required to be, written in two parts, a wrapper function and a logic function. The wrapper will manage the reading of inbound messages to the agent and generate its outbound messages, it will also update the local state of the agent. While a logic function is called by the wrapper to calculate the messages to be sent and there content. A agent written following this design could have a form similar to that of the agent show in Fig.~\ref{fig:wrapperfrominterdyne}. This agents wrapper recursively calls its self on the inbound message list, consuming the head of the list\footnote{This design dictates that the head of the list is the messages for the current time step.} and producing a list of outbound messages using a logic function.  
\begin{figure}[H]
	\centering
        \lstinputlisting[language=Haskell]{complexagentwrapper.hs}
	\caption{\it Simple wrapper function, which creates a list of output messages by iterating through a list of inbound messages and calling the sub-function $logic$.}
	\label{fig:wrapperfrominterdyne}
\end{figure} 
%-what is the harness in interdyne and what is its type

The simulator harness is an intrinsic part of the simulator, it drives the simulation, handles message passing and produces the output trace file. %need to put more here, whats its type, what does it look like?

%dont say paper 
%The simulator harness is embodied in the function called sim, the actual function sim in interdyne contains not only code to run the simulation but also code associated with writing to trace files and other admistrative funtions. for the purpioses of this project, we use the following reduced sprecification of the fucntion sim which captures the all of the core fuctionality for managing message passing for agents and driving evaluation of the simualtion

%-how do you run an interdyne experiment 

Running an InterDyne experiment is done by calling the simulator with relevant inputs, an example example of this is shown in Fig.~\ref{fig:runninginterdyne}.
\begin{figure}[H]
	\centering
        \lstinputlisting[language=Haskell]{interdynewithdelays.hs}
	\caption{\it A run of an experiment in InterDyne containing delays.}
	\label{fig:runninginterdyne}
\end{figure} 









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Description and Analysis of the Problem} \label{despriptionandanalysproblem}

Investigating emergent behaviour originating from interaction dynamics, within a complex system, relays on viewing the communication between different components of the system as messages being passed. These messages can then be analysed to assess the communication and its pattern that lead to the creation of the emergent behaviour, this approach is amenable to the discovery of phenomena, such as dynamic feedback loops. A model investigating emergent behaviour hence must be able to view communication as messages being passed between different components. For results from this model to be broadly accepted, in fields such as economics, the model as a whole must also be well defined.      

Agent-based models naturally support a message passing view making them well suited to analysing and investigating emergent behaviour. However most agent-based models, though having each individual agent be fully specified, do not have a well defined formalisation for the system as a whole. This makes it challenging to perform system wide analytics on most agent-based model. Recurrence relations naturally support a system wide analysis, due to the full definition of their models. However their formulation does not support a message passing view of communication between components, making it difficult to analyse emergent behaviour with them directly. 

This creates a problem as neither model is perfect for the task at hand. A resolution to this problem suggested by Ref.~\cite{econmistsnoabm}, is to give a formal definition of the specification of an agent-based model as a set of recurrence relations.This can be seen as viewing a system in two ways, as a recurrence relation model and as a agent-based model, a two-views approach.

%what is this section going to cover 


\subsection{Method for Achieving a Two-Views Approach}
\begin{itemize}
  \item How can this solution be achieved (translation form rr to abm)
  \item How will this translation be done (research review conclude step by step aproach)
  \item what is the project? (make rr language, convert in a step-by-step manner to InterDyne)
\end{itemize}


%%%%%%How can this solution be achieved (translation form rr to abm)

%%%%%%what is a translation between rr and abm

%%%%%%what direction should this translation take and why? rr -> abm

%%%%%%How will this translation be done? look at work other people have done on translations (step-by-step) 


%a small literay review on why to use a step by step transformtion to go between the two vies 

%for literate review
%check if any one has done this before or anything similar 
%translating from RR to anything else 
%tralsing from anything to an agent based model 
%any one written anything on porcess fo program transformation by small steps, (lots in the late 80s), le brain phd theise (2000), desgined a programing langauge, approach he took to turn it into a functional langauge using step by step transoting (clover) 
%object flaw, paper 
%the clover rewrite rules, paper (this is the one i want)
%introducing clover and object oriented  functional langue, paper 


%for literate review
%compare abm and non abm of finacial markets and say that ecomists publish different papers 
%check if any one has done this before or anything similar 
%translating from RR to anything else 
%tralsing from anything to an agent based model 
%any one written anything on porcess fo program transformation by small steps, (lots in the late 80s), le brain phd theise (2000), desgined a programing langauge, approach he took to turn it into a functional langauge using step by step transoting (clover) 
%object flaw, paper 
%the clover rewrite rules, paper (this is the one i want)
%introducing clover and object oriented  functional langue, paper 

%EXPLAIN?? explain why a step-by-step processes should be taken refrencing other work using step by step transformations
%https://www.semanticscholar.org/paper/The-Clover-Rewrite-Rules-a-Translation-from-Oofp-t-Braine-Clack/4402741aa70e4cae37839f196b5741fd6b843428
%https://pdfs.semanticscholar.org/5b13/9a35dbc63e516dd51f2cd6672d2d7b5c21b6.pdf?_ga=2.246578180.1291348853.1500637404-583838121.1500637404





%%%%%%what is the project? (make rr language, convert in a step-by-step manner to InterDyne)

%Though InterDyne is a functional simulation platform and has been used to run a number of experiments, most notably in Ref.~\cite{DynamicCoupling_Chris} where a model was presented showing a flash crash caused by interaction dynamics, it possesses a concern when discussing these results, especially to non-experts in computational modelling.\\

%To create a model tool which will allow for the two views approach, three aspects most be covered, an agent-based model,the recurrence relations, and a convertor for transforming between them. The agent-based model as already been created in the form of InterDyne and as already discussed fulfils all the needed requirements for the systems being modelled. The latter two aspects however have not been previously produced and will be the focus of this paper.   





\subsection{Challenges with the Two-Views Approach} \label{twoviewsapproach} 
\begin{itemize}
  \item what are the challenges with this method (list in intro) 
\end{itemize}

%what is the problem, why is it important, why is difficult
\begin{itemize}
   \item The two paradigms of the models are completely different and opposing. 
   \item How are function calls related to message passing?
   \item How can the idea of agents having a infinite list through out time of their values be derived from the recurrence relations? 
   \item How can the idea of private and public information introduced, and what data should fall into each category? 
   \item How can public broadcast data be introduce, and what data classifies to be treated as such? 
   \item How can time limited information be introduced?
   \item How can name control be introduced in a tangible way into a recurrence relations that have no notion of agents. 
   \item How can output messages containing message information be introduced? 
   \item How can the recurrence relations be split in a way which does not splinter the model? 
   \item How can small, and hence more susceptible to prove of correctness, steps be used to transform the model? 
\end{itemize}









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Bespoke Recurrence Relation Language}
%change order of sections


%There is a logical step here considere the set of recurrance relations to be the model of the system. this model is amenable to analysis (can analysis the model  (which is the set of rr ), with out running experiment) but sometimes we want to analysis/understand the dynamic behviour of that model given certain starting conditions. and one way of doing this is to define an expression that calcualtes some value, in the contex of this model (the rr) this expression will give the intial values 

%set of rr are not an experment they are a model

%tracing the equations (an experment)  


%need to set out inital conditons/values because we want to explore as different expemenrets what happens as we trace the equations given differeent starting conditions. 
%Drive the expemernet by evaluting a certain expression 
%need
%-set of rr
%-some way of setting out intial conditions
%-a driving expression 
%this is what we need for our input syntax. 




The first step in this translation is selecting a recurrence relation, which to translate from. Recurrence relations are used across a wide range of disciplines and as such have many different forms of notation {\color{red} [REFS????]}. It was however decided to create a bespoke recurrence relation language for use in this translation, this was done for a number of reasons:
\begin{enumerate}
  \item Need to have a strict set of rules for the language to allow for automated parsing. 
  \item Need to restrict the functionality of the language to keep it as simple as possible, to facilitate the automated translation. Only introducing complexity where necessary.  
  \item Need to maintain sufficient functionality for modelling complex systems in the language.  
\end{enumerate} 

As noted in the third point, this language as to have a certain level of functionality. 
%The initial syntax will support the syntax shown in fig 7

It was decided that the language should have the following function:
%dont have this list 
\begin{itemize}
  \item The use of basic mathematical operations.% ($+, *, /, -$).
  \item The use of lists.%($[]$).
  \item The ability to call the head of a list.% ($hd$). %hd
  \item The ability to call the tail of a list.% ($tl$). %tl
  \item The ability to add to the head of a list.% ($:$). %:
  \item The ability to index into a list.% ($!$).
  \item The ability to use brackets.% ($()$). 
  \item The ability to declare variables.  
  \item The ability to define a unique name for each recurrence relation.
  \item The ability to define unique names for groups of recurrence relations. 
  \item The ability to define a recurrence relation that uses inputs.
  \item The use of sub functions within recurrence relations. 
  \item The ability for recurrence relations to pattern match initial conditions.  
  \item The use of where blocks.% ($where$).
  \item The use of if else statements.% ($if$ $then$ $else$). 
  \item The ability to specify an entire experiment.  
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Syntax}
%lexemes as well!!!!! (look at any program and know that it is of the right syntax) with BNF (on wiki simple) (add as figure) (concrete syntax)
%Bnf of parse tree is abstract syntax

%talk about bnf, saying what the langauge can do (from the list above)

%now how we implement using miranda
%lexer
%parser
%parse tree 

%can say using miranda (refer to the miranda textbook)
%(in chapter 6)
%type name ::= algerbaic type dfintion 
% ::= paremneted value | paremented value
%::= Name <-construtor 
%::= Name num <-associated data
 %to help specifiy this precises here is the miranda algibrict type 
The formal syntax for this language is shown in Fig.~\ref{fig:parsetreecode}, this syntax is written in a style consistent with type definitions within the Miranda language. This style is that of a type followed by its values, the left hand side of $::=$ is the type and can take the form of any one of its values, on the right hand side. 

A simulation is defined as type $simulation$, which has two parts. A list of recurrence relations (list of type $definition$) and information about the simulation (of type $experiment$). 

A definition of a recurrence relation is defined as type $definition$, has one values $Function$. The value $Function$ contains to list of characters which hold the group name and the name of the recurrence relation, a list of the arguments (type $argument$) and a expression for the functionality of the recurrence relation (type $expression$). 

A argument, whether it be used for the definition of a recurrence relation or used for calling one, has one value $Argument$. This value is associated with an expression of the actual argument (type $expression$). 

The $experiment$ must take the value of $Experiment$ which has two parts, a list of initial conditions (type $initcon$) and a function call for the result of the simulation (type $experimentrun$). 

An initial condition for the recurrence relations is listed as a value $Initcon$ which has a name and an expression associated with it (type $[char]$ and $expression$ respectively), this name is used to connect the initial condition to the relevant recurrence relations. 

The $experimentrun$ can have two values, either being empty (value $Emptyrun$) or to have a function call (value $Experimentrun$). If there is a function call this has an associated $expression$ with it. 

An $expression$ can produce any expression for a recurrence relation that the language will allow, $expression$ can recursively call itself to create more complex expressions or  can call other types such as $argument$, $subdefinition$, $op$ and $specfunc$.    

The use of operations is through the type $op$, this type has a value relating to all operations that use two values.

Two operations are allowed that only use one value, returning the head of a list (value $Listhead$) and returning the tail of a list (value $Listtail$). 

The type $subdefinition$ has two values for either internal variables in a where statement ($IntVariable$) or internal functions within a where statement ($IntFunction$).  

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{Syntax_Def.lit.m}
	\caption{\it Formal definition of syntax within bespoke recurrence relation, written in style of Miranda type definitions.}
	\label{fig:parsetreecode}
\end{figure} 







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Naming Conventions}
This language has a strict naming convention, as well as some restricted names. Naming conventions are in place for recurrence relation definitions, where blocks, sub-functions, variables, initial conditions and  if statements. 

A recurrence relation be defined in four parts, $name$ $arguments$ $=$ $expression$. The name must be formatted in the manner $group\_name$, where $group$ is the name of the group the recurrence relation belongs to and $name$ is the name of the particular recurrence relation. Multiple recurrence relations can belong to the same group, and hence have the same group name, however only one relation in each group can have a set name. This language requires that all recurrence relations take at least one argument, and that time $t$ has to be the first argument. Time $t$ does not need to be utilised within the relation but it must be in the definition.     

A recurrence relation can have sub definitions relating to it, this is done through the use of a where block. A where block is written after the expression for a recurrence relation and starts with the keyword $where$. After this local definitions for internal functions and variables can be defined. 

Internal functions must be formatted in the manner $\_name$, where $name$ is the name for the function. These functions can only be accessed by the recurrence relation they are within. 

Local variables can be defined using the formate $name$, this name can be anything as long as it does not clash with restricted names. 

Initial conditions are listed in a special location in the layout, which will be show in Sec.~\ref{wellformedprogs}, and are defined in three parts $name$ $=$ $expression$. This name can be seen as a variable and can be anything not in the restricted name list. 

If statements with in this language are written as $if$ $condition$ $then$ $expression$ $else$ $expression$. Where if the condition is true, then the first expression is run and if not the second expression is.  

There are a number of names and naming conventions which can not be used and can be seen as restricted, these are:
\begin{itemize}
  \item The use of $\_$, unless it is being used for its designated purpose in recurrence relations and internal functions. 
  \item The use of the name $main$.
  \item The use of the name $init$.
  \item The use of the name $where$, unless used to make a where statement.
  \item The use of symbols, unless for their mathematical purpose.  
\end{itemize}


\subsection{Well Formed Programs} \label{wellformedprogs} 
This language has a strict style and layout, this covers a number of aspects: layout, experiment, initial conditions and recurrence relations.  

The layout of an simulation should match that shown in Fig.~\ref{fig:1exofla}, with $main$ signifying the experiment, $init$ the initial conditions and $where$ the list of recurrence relations. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{1layout.m}
	\caption{\it Layout of a simulation.}
	\label{fig:1exofla}
\end{figure} 

An experiment is written as a function call, with a certain set of arguments. Figure~\ref{fig:2exofla} shows a experiment that will return the value of the recurrence relation $i\_f1$ at time $3$.
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{2experment.m}
	\caption{\it Function call for value at time 3 in recurrence relation 1\_f1.}
	\label{fig:2exofla}
\end{figure} 
 
The initial conditions, which use will be shown later, are defined as shown in Fig.~\ref{fig:3exofla}. There is no defined  limit to the amount of initial conditions that can be defined. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{3initcons.m}
	\caption{\it Definition of two initial conditions, q and k.}
	\label{fig:3exofla}
\end{figure} 
 
A simple recurrence relation can be written as shown in Fig.~\ref{fig:4exofla}, this recurrence relation belongs to group $i$, is named $f1$ and takes one argument which is time $t$. The expression of this relation is to call itself at the previous time step and to add that to a call for another recurrence relation, from group $j$, at the previous time step. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{4rrsim.m}
	\caption{\it A simple recurrence relation, belonging to group i that adds its value at the previous time step to that of j\_f1 at the previous time step.}
	\label{fig:4exofla}
\end{figure} 
 
Initial conditions can added to recurrence relations using pattern matching, as shown in Fig.~\ref{fig:5exofla}. The recurrence relation is first written with the value for which the initial condition will be sent and this is sent to equal the initial condition, then the full recurrence relation is written.  
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{5rrint.m}
	\caption{\it Recurrence relation containing pattern matching for initial conditions.}
	\label{fig:5exofla}
\end{figure} 
 
An if statement, shown in Fig.~\ref{fig:6exofla}, can contain very complex components it is hence good practice to encase each expression with in a set of brackets to maintain legibility and correct functionality.  
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{6rrif.m}
	\caption{\it Recurrence relation using an if statement.}
	\label{fig:6exofla}
\end{figure} 
 
A where statement is used to provided additional functionality to a recurrence relation and can be used to make a expression more legible and help reduce human errors. Figure~\ref{fig:7exofla} shows the use of a where statement to add an internal variable and an internal function to a recurrence relation. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{7rrwhere.m}
	\caption{\it A recurrence relation containing a where statement to add a internal function and a internal variable.}
	\label{fig:7exofla}
\end{figure} 

This style and layout is brought together to produce a full simulation, as shown in Fig.~\ref{fig:8exofla}.
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{8full.m}
	\caption{\it A simulation in the bespoke recurrence relation language.}
	\label{fig:8exofla}
\end{figure} 







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Translation from Recurrence Relations to InterDyne} 

%we define the overal transflation as a sequnce of num steps, each stephas a specific purpose as set out below 

\begin{itemize}
  \item Re say what the convertor is and what is meant to do
  \item Re say project scope and that here the converter is only being designed 
  \item say that is takes a step by step approach and why 
  \item why? so that the steps can be shown to be correctness preserving later more easily 
  \item say what the steps are going to be 
\end{itemize}

%defines the design of each step in the conversion between recurrance relations and interdyne 

%how I will create the two views
%what the converter is meant to do


%how would this work? correctness preserving transformation 

% Eventually, we would like to be able to express the System of Systems as a set of recurrence relations and then generate the agent-based model automatically; if this could be done in a way that preserves the semantics of the specification, then we would be confident that the static and dynamic analyses are being performed on models of the same System of Systems. 

This section details the design of the transformation from a set of recurrence relations written in the previously discussed custom language into an InterDyne simulation. This transformation processes  as been split into a number of smaller steps, with each step taking the expression of the system given by the previous step and modifying it to be closer to the InterDyne formalisation.\\
The transformation has been split into small steps to avoid any large jumps in logic between different representations. Jumps in logic can make it difficult to follow the transformation and more challenging to prove the correctness of the transformation.\\
The aim of this section is to show the design of each of these transformative steps, and not to implement them into code or prove their correctness, however in some case the code may also be shown.\\
To assist in the explanation of the transformation a simple example will be used through out this section Recurrence Relation Example 1 (RRE1), this example is shown in Fig.~\ref{fig:rre1}. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRE1.m}
	\caption{\it Simple example of recurrence relations written in custom defined language.}
	\label{fig:rre1}
\end{figure} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Recurrence Relation Parser (done)}  
%explain how you get from the previous step to the current step 
%both before and after still adhere to the original bnf (apart from a list of stuff)

%validate design step (call it symatic consideration) 
%argume informally that each step does not change the meanning of the code, talk whats the step has doen and why it hasnt changed the meaning




%explain what the parser is and how it works, in preparing these files for transfermation

%programs wirtten in this language will be parsed into lexemes and then converted into a numeric type (?) which will be used to transfer this into lambda calcus and an ABM model



The recurrence relations shown in Fig.~\ref{fig:rre1} are text, and hence the first step in transforming them is to give them a representation within code. This is done by a parser in two parts, lexical analysis and syntax analysis.\\
Lexical analysis takes in the text file as a list of characters and converts this to a list of tokens representing items, such as function names.\\
Syntax analysis takes this list of tokens and stores it in a parse tree that enforces structure. This parse tree can be seen in Fig.~\ref{fig:parsetree}.  
 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{eparsetree.m}
	\caption{\it Simple example of recurrence relations written in custom defined language.}
	\label{fig:parsetree}
\end{figure} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Infinite List Outputs (done)}
%no time as a input
%use ! to refrence the list items

%all functions turned into lists
%all fucntions now contain time (even if its the same output at all time steps)
%enforce that if time is used it has to be the first argument 
%enforce all functions take t as their first agrument whether or not they use it
%when calling a fucntion that doesnt take time can just use t, or 0 

%This is done by knowing that t is a special character that goes at the begging of time dependent recurrence relations. Therefore %function: RR t a b c = f t a b c goes to RR a b c = [ expr t a b c | t <- [0..]] where expr t a b c = f t a b c 


%done need to write up

%creates a sub wrapper that gives infitie list outputs
%all calls now need to index into this 


A large difference between recurrence relations and InterDyne, is that in InterDyne communication is done using list, and not function calls. These lists are infinite, with a each element representing a value at a different time step. Though these lists are infinite in practice they are only as long as the highest time reached, as values for any time after this are not needed and hence will not be calculated. To make the recurrence relations have a similar approach to this a wrapper function for each relation needs to be made, this function will produce a infinite list containing the value of the relation at each time step, this wrapper can be seen in Fig.\ref{fig:iloc}. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{ILOC.m}
	\caption{\it Simple example of recurrence relations written in custom defined language.}
	\label{fig:iloc}
\end{figure} 
To access a value for a particular time of a relation, the bang operator, !, now has to be used. This operator applied to a list will return a specified element of the list, for example in $List!n$ the $n^{th}$ element will be returned. 
%\colorbox{blue}{\lstinline[basicstyle=\ttfamily\color{white}]|List!n|}?  
Therefore the experiment will now be written in the form shown in Fig.\ref{fig:RRiloc}. 
\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRiloc2.m}
	\caption{\it Recurrence relations with with infinite list outputs.}
	\label{fig:RRiloc}
\end{figure} 
       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wrapper Function (done)}
%group into agents
%create a wrapper agent that out puts a infinite list (in time) containing a list of the value of each RR in the wrapper for that time step
%[[rr1_t1,rr2_t2...], [rr1_t2, rr2_t2....], ..]
%other RR now have to call the outputs using !! and by referencing the wrapper
%agent na is reserved 
%external function calls refering to fucntions of the same agent have been turned into internal function calls 

%done need to write up 

%moves the functions into agents
%outputs a infite list in time with each item being a list of all outputs from the wrapper
%all calls now index into this 


\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRwfc3.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRwfc}
\end{figure} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Outputs (done)}

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRopts4.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRopts}
\end{figure} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Messages}

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRmes5.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRmes5}
\end{figure} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Queues}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Harness}
%create the harness, that takes all the lists from the different wrappers and compiles them into one list which is passed to each wrapper as an input
%this is a finite list, with each element being a difffernt wrapper
%each wrapper is an infinite list with each element being the outputs at the time step
%the outputs at the time step are a list of the values for each RR at that time

%done need to write up 


%takes wrapper out puts, list of all wrappers?
%spreads the outputs across time to create a output list that is finite 
%wrapper functions now access the harness
%take hd of data from the harness 
%wrapper function now loops 
%delay queue to access further back in time values 
%empty list input for first element of the harnesses output 
%output message

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRhc7.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRhc}
\end{figure} 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Input Messages}
%where an agent gets a list of messages to read 

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRim8.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRim}
\end{figure} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Direct Messages}
%to from messsages
%use of keys and values 

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRdm9.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRdm}
\end{figure} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Output Message}

%add a message telling the harness to output the write value 

\begin{figure}[H]
	\centering
	\lstinputlisting[language=Miranda]{RRom10.m}
	\caption{\it Recurrence relations with with wrapper functions.}
	\label{fig:RRom}
\end{figure} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Broadcast Messages}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Testing and Validation}
%test the translation code to see for bugs (my code)
%edge cases (empty file, rr that has a black hole (should give an output that has a black hole), ..)


%validate the my code 
%check it give the right outputs 



\begin{itemize}
  \item What is the validation for? checking that the conversion actual matches with an ABM (in this case InterDyne)
  \item do this by comparing types 
  \item also by checking coding syntax 
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Type Comparison to InterDyne}
%make sure agents are of type Agent_t


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conversion to Haskell}
%output the wrappers and logic as haskell code that can then be run in Interdyne 

\subsection{Testing}

\begin{itemize}
  \item checking that this conversion still produces the same results as the RR 
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
%in project scope: show some limited implementation. Say initial aim was to design, but not implement the translation steps. However, the project has succeeded in all of the design aims and additionally succeeded in implementing several of the translation steps."




%talk about what are the other benfits of creating this translation technique

%say i did more work then i intened to 



\subsection{Further Work}

\begin{itemize}
  \item Build code
  \item correctness proof 
\end{itemize}

%do the correctness preserving aspect of this
 
%\section{Appendix}

%\subsection{Appendix 1} %\label{Appendix_1}
%\lstinputlisting[language=C++]{AllCode_functions.cpp}


\addcontentsline{toc}{section}{References}
\bibliographystyle{unsrt}
\bibliography{MRes_Dissertation}







     
\end{document}










